<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title></title>
      <url>http://cgpointzero.top/2016/09/10/Swfit/swift-auto-scroll/</url>
      <content type="html"><![CDATA[<p>###Abstract</p>
<blockquote>
<p>How to automatic scroll<br>New features in Swift 3.0<br>How to Async load image with memery and disk cache policy like <code>SDWebImage</code>.</p>
</blockquote>
<p>###Introduction<br>……………………………………………………………………………………….<br>A class with ad. pics auotmatic scrolling build in swift with image cache policy used.<br><img src="http://upload-images.jianshu.io/upload_images/937405-24ff5553ed3b31ae.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>###Installtion<br>Manual:</p>
<p>Download This Project and drag the <code>FGSwiftAutoScrollView</code> folder into your peroject, do not forget to ensure “copy item if need” being selected.</p>
<p>###Usage</p>
<ul>
<li><p>Load Web Images：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    //MARK:-</span><br><span class="line">    //MARK:automatic scrollView with web images</span><br><span class="line">    convenience init(frame:CGRect, placeHolder placeHolderImage:UIImage?,remoteImageUrls imgs:Array&lt;String&gt;?, selectImageAction imageDidSelectedAction:@escaping FGImageClickBlock)&#123;</span><br><span class="line">        </span><br><span class="line">        self.init(frame: frame)</span><br><span class="line">        self.createLoacalCacheFolder()</span><br><span class="line">        self.placeHolderImage=placeHolderImage</span><br><span class="line">        self.didSelectedImageAction=imageDidSelectedAction</span><br><span class="line">        self.imageUrlArray=imgs</span><br><span class="line">        DispatchQueue.main.async &#123;</span><br><span class="line">            self.createScrollView()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Load Local Images：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    //MARK:automatic scrollView with local images</span><br><span class="line">    convenience init(frame:CGRect,placeHolder placeHolderImage:UIImage?,localImageNames imgs:Array&lt;String&gt;?, selectImageAction imageDidSelectedAction:@escaping FGImageClickBlock)&#123;</span><br><span class="line">        </span><br><span class="line">        self.init(frame: frame)</span><br><span class="line">        self.placeHolderImage=placeHolderImage</span><br><span class="line">        var fileUrlsArray:Array&lt;String&gt;=[]</span><br><span class="line">        for name in imgs!&#123;</span><br><span class="line">            </span><br><span class="line">            var path:String?</span><br><span class="line">            if name.hasSuffix(&quot;jpg&quot;)||name.hasSuffix(&quot;png&quot;)&#123;</span><br><span class="line">                path=Bundle.main.path(forResource: name, ofType: nil)</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                path=Bundle.main.path(forResource: name, ofType: &quot;png&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            if path==nil&#123;</span><br><span class="line">                path=&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            path=path?.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)</span><br><span class="line">            let fullPath=String.init(format: &quot;file://%@&quot;, path!)</span><br><span class="line">            fileUrlsArray.append(fullPath)</span><br><span class="line">        &#125;</span><br><span class="line">        self.didSelectedImageAction=imageDidSelectedAction</span><br><span class="line">        self.imageUrlArray=fileUrlsArray</span><br><span class="line">        self.createScrollView()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>you can simply use the srcoll call back block if need (not necessary)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.banner?.imageDidScrolledBlock=&#123; (currentIndex) in</span><br><span class="line"></span><br><span class="line">    print(&quot;滚到到了第&quot;+String(currentIndex)+&quot;页了&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>###Explain：<br>If you don’t need add image tap action, property didSelectedImageAction  block can be nil.</p>
<p>###How to implementation</p>
<blockquote>
<p>Create a class:<code>FGSwiftAutoScrollView.swift</code> and confirm to the UIScrollViewDelegate</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class FGSwiftAutoScrollView: UIView,UIScrollViewDelegate&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Add some properties</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//auto scroll interval</span><br><span class="line">    let fg_scrollInterval=3.0</span><br><span class="line">    //disk cache path</span><br><span class="line">    let fg_cachePath=NSSearchPathForDirectoriesInDomains(.libraryDirectory, .userDomainMask, true).last!+&quot;/FGGAutomaticScrollViewCache&quot;</span><br><span class="line">    //memery cache</span><br><span class="line">    let fg_imageCache=NSCache&lt;AnyObject,AnyObject&gt;()</span><br><span class="line">    //maximun disk chache cycle</span><br><span class="line">    let fg_maxCacheCycle=TimeInterval(7*24*3600)</span><br><span class="line">    // tap image call action call back</span><br><span class="line">    private var didSelectedImageAction:FGImageClickBlock?</span><br><span class="line">    //image did scrolled call back</span><br><span class="line">    public var  imageDidScrolledBlock:FGImageScrolledBlock?</span><br><span class="line">    //data source</span><br><span class="line">    public var  imageUrlArray:Array&lt;String&gt;?&#123;</span><br><span class="line">        //redifine setter</span><br><span class="line">        didSet&#123;</span><br><span class="line">            //refresh UI on main queue</span><br><span class="line">            DispatchQueue.main.async &#123;</span><br><span class="line">                </span><br><span class="line">                self.createScrollView()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //main scrollView</span><br><span class="line">    private var scroll:UIScrollView?</span><br><span class="line">    //to ensure automatic scroll</span><br><span class="line">    private var timer:Timer!</span><br><span class="line">    //page control to show current page index</span><br><span class="line">    private var pageControl:UIPageControl!</span><br><span class="line">    //placeHolder image</span><br><span class="line">    var placeHolderImage:UIImage?</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Override initWithFrame:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">override init(frame:CGRect)&#123;</span><br><span class="line">        super.init(frame:frame)</span><br><span class="line">        self.createLoacalCacheFolder()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Create an area for disk image cache</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//MARK:- create cache area</span><br><span class="line">    //MARK:create a cache area to cache web images</span><br><span class="line">    private func createLoacalCacheFolder()&#123;</span><br><span class="line">        </span><br><span class="line">        if !FileManager.default.fileExists(atPath: fg_cachePath)&#123;</span><br><span class="line">            do&#123;</span><br><span class="line">                try FileManager.default.createDirectory(atPath: fg_cachePath, withIntermediateDirectories: true, attributes: nil)</span><br><span class="line">                </span><br><span class="line">            &#125;catch&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Give two convenience functions</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//MARK:-Load Web Image</span><br><span class="line">    //MARK:automatic scrollView with web images</span><br><span class="line">    convenience init(frame:CGRect, placeHolder placeHolderImage:UIImage?,remoteImageUrls imgs:Array&lt;String&gt;?, selectImageAction imageDidSelectedAction:@escaping FGImageClickBlock)&#123;</span><br><span class="line">        </span><br><span class="line">        self.init(frame: frame)</span><br><span class="line">        self.placeHolderImage=placeHolderImage</span><br><span class="line">        self.didSelectedImageAction=imageDidSelectedAction</span><br><span class="line">        self.imageUrlArray=imgs</span><br><span class="line">        DispatchQueue.main.async &#123;</span><br><span class="line">            self.createScrollView()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//MARK:Load Local Image</span><br><span class="line">    //MARK:automatic scrollView with local images</span><br><span class="line">    convenience init(frame:CGRect,placeHolder placeHolderImage:UIImage?,localImageNames imgs:Array&lt;String&gt;?, selectImageAction imageDidSelectedAction:@escaping FGImageClickBlock)&#123;</span><br><span class="line">        </span><br><span class="line">        self.init(frame: frame)</span><br><span class="line">        self.placeHolderImage=placeHolderImage</span><br><span class="line">        var fileUrlsArray:Array&lt;String&gt;=[]</span><br><span class="line">        for name in imgs!&#123;</span><br><span class="line">            </span><br><span class="line">            var path:String?</span><br><span class="line">            if name.hasSuffix(&quot;jpg&quot;)||name.hasSuffix(&quot;png&quot;)&#123;</span><br><span class="line">                path=Bundle.main.path(forResource: name, ofType: nil)</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                path=Bundle.main.path(forResource: name, ofType: &quot;png&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            if path==nil&#123;</span><br><span class="line">                path=&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            path=path?.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)</span><br><span class="line">            let fullPath=String.init(format: &quot;file://%@&quot;, path!)</span><br><span class="line">            fileUrlsArray.append(fullPath)</span><br><span class="line">        &#125;</span><br><span class="line">        self.didSelectedImageAction=imageDidSelectedAction</span><br><span class="line">        self.imageUrlArray=fileUrlsArray</span><br><span class="line">        self.createScrollView()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Create main scroll view</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">//MARK:-</span><br><span class="line">    //MARK:create scroll view</span><br><span class="line">    private func createScrollView()&#123;</span><br><span class="line">        </span><br><span class="line">        if self.scroll != nil&#123;</span><br><span class="line">            </span><br><span class="line">            for sub in self.subviews &#123;</span><br><span class="line">                </span><br><span class="line">                sub.removeFromSuperview()</span><br><span class="line">            &#125;</span><br><span class="line">            self.scroll?.removeFromSuperview()</span><br><span class="line">            self.scroll=nil</span><br><span class="line">        &#125;</span><br><span class="line">        self.scroll=UIScrollView.init(frame: self.bounds)</span><br><span class="line">        self.addSubview(self.scroll!)</span><br><span class="line">        self.scroll?.delegate=self</span><br><span class="line">        var count:Int?;</span><br><span class="line">        if self.imageUrlArray==nil&#123;</span><br><span class="line">            count=0</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            count=self.imageUrlArray?.count</span><br><span class="line">        &#125;</span><br><span class="line">        let width:CGFloat=CGFloat((count!+1))*self.bounds.size.width;</span><br><span class="line">        let height:CGFloat=self.bounds.size.height;</span><br><span class="line">        self.scroll?.contentSize=CGSize.init(width: width, height: height)</span><br><span class="line">        </span><br><span class="line">        self.scroll?.isPagingEnabled=true</span><br><span class="line">        self.scroll?.showsHorizontalScrollIndicator=false</span><br><span class="line">        </span><br><span class="line">        if self.timer != nil&#123;</span><br><span class="line">            </span><br><span class="line">            self.timer.invalidate()</span><br><span class="line">            self.timer=nil</span><br><span class="line">        &#125;</span><br><span class="line">        //detach the timer</span><br><span class="line">        self.timer=Timer.scheduledTimer(withTimeInterval: fg_scrollInterval, repeats: true, block: &#123; (t) in</span><br><span class="line">            </span><br><span class="line">            if self.imageUrlArray?.count==0&#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            var index=Int((self.scroll?.contentOffset.x)!/self.bounds.size.width);</span><br><span class="line">            index+=1</span><br><span class="line">            if index==self.imageUrlArray?.count&#123;</span><br><span class="line">                index=0</span><br><span class="line">            &#125;</span><br><span class="line">            if self.imageDidScrolledBlock != nil&#123;</span><br><span class="line">                </span><br><span class="line">                self.imageDidScrolledBlock?(UInt(index))</span><br><span class="line">            &#125;</span><br><span class="line">            self.pageControl.currentPage=index</span><br><span class="line">            UIView.animate(withDuration: 0.2, animations: &#123;</span><br><span class="line">                self.scroll?.contentOffset=CGPoint.init(x: self.bounds.size.width*CGFloat(index), y: 0)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        if count!&gt;0&#123;</span><br><span class="line">            for i in 0...count!&#123;</span><br><span class="line">                </span><br><span class="line">                let xpos=CGFloat(i)*self.bounds.size.width</span><br><span class="line">                let frm=CGRect.init(x: xpos, y: 0, width: self.bounds.size.width, height: self.bounds.size.height)</span><br><span class="line">                let imv=UIImageView.init(frame: frm)</span><br><span class="line">                imv.image=self.placeHolderImage</span><br><span class="line">                imv.isUserInteractionEnabled=true</span><br><span class="line">                let tap:UITapGestureRecognizer=UITapGestureRecognizer.init(target: self, action:#selector(FGSwiftAutoScrollView.tapImage))</span><br><span class="line">                imv.addGestureRecognizer(tap)</span><br><span class="line">                self.scroll?.addSubview(imv)</span><br><span class="line">                var urlString:String?</span><br><span class="line">                if i&lt;count!&#123;</span><br><span class="line">                    </span><br><span class="line">                    urlString=self.imageUrlArray?[i]</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    urlString=imageUrlArray?.first</span><br><span class="line">                &#125;</span><br><span class="line">                self.fg_setImageWithUrlString(imageView: imv,</span><br><span class="line">                                              urlString: urlString,</span><br><span class="line">                                              placeHolder:self.placeHolderImage)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if self.pageControl != nil&#123;</span><br><span class="line">            self.pageControl.removeFromSuperview()</span><br><span class="line">            self.pageControl=nil</span><br><span class="line">        &#125;</span><br><span class="line">        let pageControlFrame=CGRect.init(x: 0, y: 0, width: 200, height: 17)</span><br><span class="line">        self.pageControl=UIPageControl.init(frame: pageControlFrame)</span><br><span class="line">        self.pageControl.center=CGPoint.init(x: self.bounds.size.width/2, y: self.bounds.size.height-10)</span><br><span class="line">        self.pageControl.numberOfPages=count!</span><br><span class="line">        self.pageControl.pageIndicatorTintColor=UIColor.init(red: 225.0/255.0, green: 225.0/255.0, blue: 225.0/255.0, alpha: 1.0)</span><br><span class="line">        self.pageControl.currentPageIndicatorTintColor=UIColor.orange</span><br><span class="line">        self.addSubview(self.pageControl)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Impletatin of sroll view delegate</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//MARK:-</span><br><span class="line">    //MARK:UIScrollView Delegate</span><br><span class="line">    func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) &#123;</span><br><span class="line">        </span><br><span class="line">        var index=Int((self.scroll?.contentOffset.x)!/self.bounds.size.width);</span><br><span class="line">        if index==self.imageUrlArray?.count&#123;</span><br><span class="line">            index=0;</span><br><span class="line">        &#125;</span><br><span class="line">        if self.imageDidScrolledBlock != nil&#123;</span><br><span class="line">            </span><br><span class="line">            self.imageDidScrolledBlock?(UInt(index))</span><br><span class="line">        &#125;</span><br><span class="line">        self.pageControl.currentPage=index</span><br><span class="line">        self.scroll?.contentOffset=CGPoint.init(x: self.bounds.size.width*CGFloat(index), y: 0)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Implementation of tap image action</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//MARK:-</span><br><span class="line">    //MARK: Tag Image Action</span><br><span class="line">    func tapImage()&#123;</span><br><span class="line">        </span><br><span class="line">        if self.didSelectedImageAction != nil&#123;</span><br><span class="line">            </span><br><span class="line">            self.didSelectedImageAction?(UInt(self.pageControl.currentPage));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Destroy the timer in deinit</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deinit&#123;</span><br><span class="line">        if self.timer != nil&#123;</span><br><span class="line">            self.timer .invalidate()</span><br><span class="line">            self.timer=nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Write an extension to async download image like <code>SDWebImage</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extension FGSwiftAutoScrollView&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Async image loading like <code>SDWebImage</code> with cache in memery an disk</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">    func fg_setImageWithUrlString(imageView:UIImageView?,urlString:String?,placeHolder:UIImage?)&#123;</span><br><span class="line">        </span><br><span class="line">        if imageView==nil&#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        imageView?.image=placeHolder</span><br><span class="line">        if urlString==nil&#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        var cachePath=fg_cachePath+&quot;/&quot;+String(describing: urlString?.hash)</span><br><span class="line">        if (urlString?.hasPrefix(&quot;file://&quot;))!&#123;//local path</span><br><span class="line">            cachePath=urlString!</span><br><span class="line">        &#125;</span><br><span class="line">        //check the memery chache exist or not(both local and web images)</span><br><span class="line">        var data=fg_imageCache.object(forKey: cachePath as AnyObject)</span><br><span class="line">        if (data != nil) &#123;//exist in memery cache</span><br><span class="line">            </span><br><span class="line">            DispatchQueue.main.async&#123;</span><br><span class="line">                imageView?.image=UIImage(data: data as! Data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;//not in memery cache,check if exist in disk or not</span><br><span class="line">            //local images</span><br><span class="line">            if (urlString?.hasPrefix(&quot;file://&quot;))!&#123;</span><br><span class="line">                </span><br><span class="line">                let url:NSURL=NSURL.init(string: urlString!)!</span><br><span class="line">                do&#123;</span><br><span class="line">                    try data=Data.init(contentsOf: url as URL) as AnyObject?</span><br><span class="line">                &#125;catch&#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                //if local image exist</span><br><span class="line">                if data != nil&#123;</span><br><span class="line">                    </span><br><span class="line">                    fg_imageCache.setObject(data as AnyObject, forKey: cachePath as AnyObject)</span><br><span class="line">                    DispatchQueue.main.async&#123;</span><br><span class="line">                        imageView?.image=UIImage(data: data as! Data)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;//local image is not exist,just ingnore</span><br><span class="line">                    //ingnore</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                //web images</span><br><span class="line">            else&#123;</span><br><span class="line">                //check if exist in disk</span><br><span class="line">                let exist=FileManager.default.fileExists(atPath: cachePath)</span><br><span class="line">                if exist &#123;//exist in disk</span><br><span class="line">                    //check if expired</span><br><span class="line">                    var attributes:Dictionary&lt;FileAttributeKey,Any&gt;?</span><br><span class="line">                    do&#123;</span><br><span class="line">                        try attributes=FileManager.default.attributesOfItem(atPath: cachePath)</span><br><span class="line">                    &#125;catch&#123;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    let createDate:Date?=attributes?[FileAttributeKey.creationDate] as! Date?</span><br><span class="line">                    let interval:TimeInterval?=Date.init().timeIntervalSince(createDate!)</span><br><span class="line">                    let expired=(interval! &gt; fg_maxCacheCycle)</span><br><span class="line">                    if expired&#123;//expired</span><br><span class="line">                        //download image</span><br><span class="line">                        self.donwloadDataAndRefreshImageView(imageView: imageView, urlString: urlString, cachePath: cachePath)</span><br><span class="line">                    &#125;</span><br><span class="line">                    else&#123;//not expired</span><br><span class="line">                        //load from disk</span><br><span class="line">                        let url:NSURL=NSURL.init(string: urlString!)!</span><br><span class="line">                        do&#123;</span><br><span class="line">                            try data=Data.init(contentsOf: url as URL) as AnyObject?</span><br><span class="line">                        &#125;catch&#123;</span><br><span class="line">                            </span><br><span class="line">                        &#125;</span><br><span class="line">                        if data != nil&#123;//if has data</span><br><span class="line">                            //cached in memery</span><br><span class="line">                            fg_imageCache.setObject(data as AnyObject, forKey: cachePath as AnyObject)</span><br><span class="line">                            DispatchQueue.main.async&#123;</span><br><span class="line">                                imageView?.image=UIImage(data: data as! Data)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else&#123;//has not data</span><br><span class="line">                            //remove item from disk</span><br><span class="line">                            let url:NSURL=NSURL.init(string: urlString!)!</span><br><span class="line">                            do&#123;</span><br><span class="line">                                try data=Data.init(contentsOf: url as URL) as AnyObject?</span><br><span class="line">                            &#125;catch&#123;</span><br><span class="line">                                </span><br><span class="line">                            &#125;</span><br><span class="line">                            //donwload agin</span><br><span class="line">                            self.donwloadDataAndRefreshImageView(imageView: imageView, urlString: urlString, cachePath: cachePath)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                    //not exist in disk</span><br><span class="line">                else&#123;</span><br><span class="line">                    //download image</span><br><span class="line">                    self.donwloadDataAndRefreshImageView(imageView: imageView, urlString: urlString, cachePath: cachePath)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Donwload Image Task</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//async download image</span><br><span class="line">    private func donwloadDataAndRefreshImageView(imageView:UIImageView?,urlString:String?,cachePath:String!)&#123;</span><br><span class="line">        </span><br><span class="line">        do&#123;</span><br><span class="line">            try FileManager.default.removeItem(atPath: cachePath)</span><br><span class="line">        &#125;catch&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        //download data</span><br><span class="line">        let url=URL.init(string: urlString!)</span><br><span class="line">        let session=URLSession.shared.dataTask(with: url!, completionHandler: &#123; (resultData, res, err) in</span><br><span class="line">            let fileUrl=URL.init(fileURLWithPath: cachePath)</span><br><span class="line">            do&#123;</span><br><span class="line">                try resultData?.write(to: fileUrl, options:.atomic)</span><br><span class="line">            &#125;catch&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            self.fg_imageCache.setObject(resultData as AnyObject, forKey: cachePath as AnyObject)</span><br><span class="line">            if resultData != nil&#123;</span><br><span class="line">                DispatchQueue.main.async&#123;</span><br><span class="line">                    imageView?.image=UIImage(data: resultData!)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                //ingnore</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        session.resume()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>End. Attached the address of my source code on GitHub</p>
</blockquote>
<p><a href="https://github.com/Insfgg99x/FGSwiftAutoScrollView" target="_blank" rel="external">FGSwiftAutoScrollView</a> Hope your star, fork or pull request.</p>
<p>###Support Me</p>
<ul>
<li>Blog:     <a href="http://cgpointzero.top">CGPointZeero</a></li>
<li>GitHub:   <a href="https://github.com/Insfgg99x" target="_blank" rel="external">Insfgg99x</a></li>
<li>Mooc:     <a href="http://www.imooc.com/u/3909164/articles" target="_blank" rel="external">CGPointZero</a></li>
<li>Jianshu:  <a href="http://www.jianshu.com/users/c3f2e8c87dc4/latest_articles" target="_blank" rel="external">CGPointZero</a></li>
<li>Email:    <a href="mailto:newbox0512@yahoo.com" target="_blank" rel="external">newbox0512@yahoo.com</a></li>
</ul>
<p>……………………………………………………………………………………</p>
<p>Copyright (c) 2016 CGPointZero. All rights reserved.<br><br><img src="http://upload-images.jianshu.io/upload_images/937405-e91a649f7a7df2a0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS开发之只用一个方法实现图片的轮播]]></title>
      <url>http://cgpointzero.top/2016/09/07/banner/</url>
      <content type="html"><![CDATA[<p>##摘要<br>本文详细的讲述了如何封装一个只用一个方法就实现自动循环轮播的广告视图，依赖于SDWebImage。</p>
<p>###效果图<br><img src="http://upload-images.jianshu.io/upload_images/937405-a37caa1ed0f1cefd.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h3 id="FGGAutomaticScrollView简介："><a href="#FGGAutomaticScrollView简介：" class="headerlink" title="FGGAutomaticScrollView简介："></a>FGGAutomaticScrollView简介：</h3><hr>
<p> 初始化方法，两种：</p>
<p>1.从网络加载图片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[FGGAutoScrollView alloc] initWithFrame:(CGRect)frame</span><br><span class="line">                               imageURLs:(NSArray *)URLArray</span><br><span class="line">                   imageDidSelectedBlock:(FGGImageClickBlock) didSelectedImageAtIndex];</span><br></pre></td></tr></table></figure></p>
<p>2.从本地加载图片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[FGGAutoScrollView alloc] initWithFrame:(CGRect)frame</span><br><span class="line">                         localImageNames:(NSArray *)imageNames </span><br><span class="line">                   imageDidSelectedBlock:(FGGImageClickBlock) didSelectedImageAtIndex;</span><br></pre></td></tr></table></figure></p>
<p> 提示：</p>
<h2 id="若不需要为图片添加点击事件，初始化时，点击图片的回调block置为nil就可以了。"><a href="#若不需要为图片添加点击事件，初始化时，点击图片的回调block置为nil就可以了。" class="headerlink" title=" 若不需要为图片添加点击事件，初始化时，点击图片的回调block置为nil就可以了。"></a> 若不需要为图片添加点击事件，初始化时，点击图片的回调block置为nil就可以了。</h2><p>###使用示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NSArray *array = @[@&quot;http://i.okaybuy.cn/images/multipic/new/201506/fe/fe6b322427edad3dd6c7916116a9a15b.jpg,</span><br><span class="line">&quot;@&quot;http://i.okaybuy.cn/images/multipic/new/201505/88/888d8cf6a769c401af2ced0140fa90f3.jpg&quot;,</span><br><span class="line">@&quot;http://i.okaybuy.cn/images/multipic/new/201506/53/532a6028830f9d7e39b5bce9e5e60e52.jpg&quot;];</span><br><span class="line"></span><br><span class="line">_bannerView=[[FGGAutoScrollView alloc]initWithFrame:CGRectMake(20, 100, self.view.frame.size.width-40, 200) placeHolderImage:nil imageURLs:array imageDidSelectedBlock:^(NSInteger selectedIndex) &#123;</span><br><span class="line">        switch (selectedIndex) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                NSLog(@&quot;你选择了第%ld张图片&quot;,selectedIndex);</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                NSLog(@&quot;你选择了第%ld张图片&quot;,selectedIndex);</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                NSLog(@&quot;你选择了第%ld张图片&quot;,selectedIndex);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">[self.view addSubview:_bannerView];</span><br></pre></td></tr></table></figure></p>
<p>若你想添加自动滚动的回调事件（可不设置）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_bannerView.imageDidScrolledBlock=^(NSInteger index)&#123;</span><br><span class="line">        NSLog(@&quot;滚动到了第%ld张&quot;,index);</span><br><span class="line">    &#125;;</span><br><span class="line"> [self.view addSubview:_bannerView];</span><br></pre></td></tr></table></figure></p>
<p>若你的图片是从链接是从网上获取的，你可以在获取图片的数组<code>imgsArray</code>后，调用set方法即可替换数据源，并且会自动reload视图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_bannerView.imageURLArray=imgsArray;</span><br></pre></td></tr></table></figure></p>
<p>##实现细节<br>搞一个自定义的视图<code>`FGGAutoScrollView</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface FGGAutoScrollView : UIView&lt;UIScrollViewDelegate&gt;</span><br></pre></td></tr></table></figure></p>
<p>设置如下属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**点击照片的回调*/</span><br><span class="line">@property(nonatomic,copy,readonly)FGGImageClickBlock    didSelectedImageAtIndex;</span><br><span class="line"></span><br><span class="line">@property(nonatomic,copy) FGGImageScrolledBlock         imageDidScrolledBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *    图片的urlString链接数组</span><br><span class="line"> *    </span><br><span class="line"> *    可以通过调用其set方法，来重载数据源和视图</span><br><span class="line"> */</span><br><span class="line">@property(nonatomic,strong)NSArray                      *imageURLArray;</span><br></pre></td></tr></table></figure></p>
<p>滚动时间间隔：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  滚动时间间隔 可以自己修改</span><br><span class="line"> */</span><br><span class="line">static double kFGGScrollInterval = 3.0f;</span><br></pre></td></tr></table></figure></p>
<p>加载网络图片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  加载网络图片滚动</span><br><span class="line"> *</span><br><span class="line"> *  @param frame    frame</span><br><span class="line"> *  @param URLArray 包含图片URL字符串的数组</span><br><span class="line"> *  @param didSelectedImageAtIndex 点击图片时回调的block</span><br><span class="line"> *</span><br><span class="line"> *  @return FGGAutoScrollView对象</span><br><span class="line"> */</span><br><span class="line">-(instancetype)initWithFrame:(CGRect)frame placeHolderImage:(UIImage *)placeHolderImage imageURLs:(NSArray *)URLArray imageDidSelectedBlock:(FGGImageClickBlock) didSelectedImageAtIndex;</span><br></pre></td></tr></table></figure></p>
<p>加载本地图片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  加载本地图片滚动</span><br><span class="line"> *</span><br><span class="line"> *  @param frame      frame</span><br><span class="line"> *  @param imageNames 本地图片名字数组</span><br><span class="line"> *  @param didSelectedImageAtIndex 点击图片时回调的block</span><br><span class="line"> *</span><br><span class="line"> *  @return FGGAutoScrollView对象</span><br><span class="line"> */</span><br><span class="line">-(instancetype)initWithFrame:(CGRect)frame placeHolderImage:(UIImage *)placeHolderImage localImageNames:(NSArray *)imageNames imageDidSelectedBlock:(FGGImageClickBlock) didSelectedImageAtIndex;</span><br></pre></td></tr></table></figure></p>
<p>##实现 FGGAutoScrollView.m</p>
<p>在拓展中添加一个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface FGGAutoScrollView()</span><br><span class="line">/**</span><br><span class="line"> *  滚动视图对象（只读）</span><br><span class="line"> */</span><br><span class="line">@property(nonatomic,strong,readonly)UIScrollView        *scroll;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>添加计数器，默认图片等成员变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@implementation FGGAutoScrollView&#123;</span><br><span class="line">    </span><br><span class="line">    //定时器</span><br><span class="line">    NSTimer *_timer;</span><br><span class="line">    //页码控制器</span><br><span class="line">    UIPageControl *_pageControl;</span><br><span class="line">    /**默认图片*/</span><br><span class="line">    UIImage *_placeHolderImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加载网络图片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//加载网络图片的方法</span><br><span class="line">-(instancetype)initWithFrame:(CGRect)frame placeHolderImage:(UIImage *)placeHolderImage imageURLs:(NSArray *)URLArray imageDidSelectedBlock:(FGGImageClickBlock)didSelectedImageAtIndex&#123;</span><br><span class="line">    </span><br><span class="line">    if(self=[super initWithFrame:frame])&#123;</span><br><span class="line">        </span><br><span class="line">        _placeHolderImage=placeHolderImage;</span><br><span class="line">        _imageURLArray=URLArray;</span><br><span class="line">        _didSelectedImageAtIndex=didSelectedImageAtIndex;</span><br><span class="line">        [self createScrollView];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加载本地图片:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//加载本地的图片的方法</span><br><span class="line">-(instancetype)initWithFrame:(CGRect)frame placeHolderImage:(UIImage *)placeHolderImage localImageNames:(NSArray *)imageNames imageDidSelectedBlock:(FGGImageClickBlock)didSelectedImageAtIndex&#123;</span><br><span class="line">    </span><br><span class="line">    if(self=[super initWithFrame:frame])&#123;</span><br><span class="line">        </span><br><span class="line">        if(imageNames.count&gt;0)&#123;</span><br><span class="line">            </span><br><span class="line">            _placeHolderImage=placeHolderImage;</span><br><span class="line">            NSMutableArray *fullPathArray=[NSMutableArray array];</span><br><span class="line">            for(int i=0;i&lt;imageNames.count;i++)&#123;</span><br><span class="line">                </span><br><span class="line">                NSString *path;</span><br><span class="line">                NSString *name=imageNames[i];</span><br><span class="line">                if([name hasSuffix:@&quot;jpg&quot;][name hasSuffix:@&quot;png&quot;])</span><br><span class="line">                    path=[[NSBundle mainBundle] pathForResource:name ofType:nil];</span><br><span class="line">                else</span><br><span class="line">                    path=[[NSBundle mainBundle] pathForResource:name ofType:@&quot;png&quot;];</span><br><span class="line">                NSString *fullPath=[NSString stringWithFormat:@&quot;file://%@&quot;,[path stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]];</span><br><span class="line">                [fullPathArray addObject:fullPath];</span><br><span class="line">            &#125;</span><br><span class="line">            _imageURLArray=fullPathArray;</span><br><span class="line">            _didSelectedImageAtIndex=didSelectedImageAtIndex;</span><br><span class="line">            [self createScrollView];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建滚动视图，添加点击手势：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//构建循环滚动视图</span><br><span class="line">-(void)createScrollView&#123;</span><br><span class="line">    </span><br><span class="line">    if(_scroll)&#123;</span><br><span class="line">        </span><br><span class="line">        for(UIView *sub in _scroll.subviews)</span><br><span class="line">            [sub removeFromSuperview];</span><br><span class="line">        [_scroll removeFromSuperview];</span><br><span class="line">        _scroll=nil;</span><br><span class="line">    &#125;</span><br><span class="line">    _scroll=[[UIScrollView alloc]initWithFrame:self.bounds];</span><br><span class="line">    [self addSubview:_scroll];</span><br><span class="line">    _scroll.delegate=self;</span><br><span class="line">    _scroll.contentSize=CGSizeMake((_imageURLArray.count+1)*self.bounds.size.width, self.bounds.size.height);</span><br><span class="line">    </span><br><span class="line">    _scroll.pagingEnabled=YES;</span><br><span class="line">    _scroll.showsHorizontalScrollIndicator=NO;</span><br><span class="line">    if(_timer)&#123;</span><br><span class="line">        </span><br><span class="line">        [_timer invalidate];</span><br><span class="line">        _timer=nil;</span><br><span class="line">    &#125;</span><br><span class="line">    _timer=[NSTimer scheduledTimerWithTimeInterval:kFGGScrollInterval</span><br><span class="line">                                            target:self</span><br><span class="line">                                          selector:@selector(automaticScroll)</span><br><span class="line">                                          userInfo:nil</span><br><span class="line">                                           repeats:YES];</span><br><span class="line">    for(int i=0;i&lt;=_imageURLArray.count;i++)&#123;</span><br><span class="line">        </span><br><span class="line">        CGFloat xpos=i*self.bounds.size.width;</span><br><span class="line">        UIImageView *imv=[[UIImageView alloc]initWithFrame:CGRectMake(xpos, 0, self.bounds.size.width, self.bounds.size.height)];</span><br><span class="line">        //设置灰色底</span><br><span class="line">        imv.image=_placeHolderImage;</span><br><span class="line">        imv.userInteractionEnabled=YES;</span><br><span class="line">        </span><br><span class="line">        //添加点击图片的手势</span><br><span class="line">        UITapGestureRecognizer *tap=[[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tapImage)];</span><br><span class="line">        [imv addGestureRecognizer:tap];</span><br><span class="line">        [_scroll addSubview:imv];</span><br><span class="line">        NSString *urlString;</span><br><span class="line">        if(i&lt;_imageURLArray.count)</span><br><span class="line">            urlString=_imageURLArray[i];</span><br><span class="line">        else</span><br><span class="line">            urlString=_imageURLArray[0];</span><br><span class="line">        NSURL *url=[NSURL URLWithString:urlString];</span><br><span class="line">        [imv sd_setImageWithURL:url placeholderImage:_placeHolderImage];</span><br><span class="line">    &#125;</span><br><span class="line">    if(_pageControl)</span><br><span class="line">        _pageControl=nil;</span><br><span class="line">    _pageControl=[[UIPageControl alloc]init];</span><br><span class="line">    _pageControl.center=CGPointMake(self.bounds.size.width/2, self.bounds.size.height-10);</span><br><span class="line">    _pageControl.numberOfPages=_imageURLArray.count;</span><br><span class="line">    _pageControl.currentPage=0;</span><br><span class="line">    _pageControl.pageIndicatorTintColor=[UIColor whiteColor];</span><br><span class="line">    _pageControl.currentPageIndicatorTintColor=[UIColor orangeColor];</span><br><span class="line">    [self addSubview:_pageControl];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自动滚动的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  自动循环滚动</span><br><span class="line"> */</span><br><span class="line">-(void)automaticScroll&#123;</span><br><span class="line">    </span><br><span class="line">    if(_imageURLArray.count&gt;0)&#123;</span><br><span class="line">        </span><br><span class="line">        NSInteger index=_scroll.contentOffset.x/self.bounds.size.width;</span><br><span class="line">        index++;</span><br><span class="line">        if(index==_imageURLArray.count)</span><br><span class="line">            index=0;</span><br><span class="line">        if(self.imageDidScrolledBlock)</span><br><span class="line">            self.imageDidScrolledBlock(index);</span><br><span class="line">        _pageControl.currentPage=index;</span><br><span class="line">        __weak typeof(self) weakSelf=self;</span><br><span class="line">        //添加滚动动画</span><br><span class="line">        [UIView animateWithDuration:0.2 animations:^&#123;</span><br><span class="line">           weakSelf.scroll.contentOffset=CGPointMake(index*self.bounds.size.width, 0);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>点击图片的回调：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//点击图片时回调代码块</span><br><span class="line">-(void)tapImage&#123;</span><br><span class="line">    </span><br><span class="line">    if(self.didSelectedImageAtIndex)&#123;</span><br><span class="line">        </span><br><span class="line">        self.didSelectedImageAtIndex(_pageControl.currentPage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重写数据源的set方法，以重载视图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**图片数组的setter方法*/</span><br><span class="line">-(void)setImageURLArray:(NSArray *)imageURLArray&#123;</span><br><span class="line">    </span><br><span class="line">    if(![imageURLArray isKindOfClass:[NSArray class]])</span><br><span class="line">        return;</span><br><span class="line">    _imageURLArray=imageURLArray;</span><br><span class="line">    if(_imageURLArray.count==0)</span><br><span class="line">        return;</span><br><span class="line">    [self createScrollView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>滚动的代理方法，若设置了滚动的回调，则在这个方法里回调<code>imageDidScrolledBlock</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - UIScrollView</span><br><span class="line">-(void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123;</span><br><span class="line">    </span><br><span class="line">    NSInteger index=_scroll.contentOffset.x/self.bounds.size.width;</span><br><span class="line">    if(index==_imageURLArray.count)</span><br><span class="line">        index=0;</span><br><span class="line">    if(self.imageDidScrolledBlock)</span><br><span class="line">        self.imageDidScrolledBlock(index);</span><br><span class="line">    _pageControl.currentPage=index;</span><br><span class="line">    _scroll.contentOffset=CGPointMake(self.bounds.size.width*index, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后在delloc中销毁计时器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//销毁</span><br><span class="line">-(void)dealloc&#123;</span><br><span class="line">    </span><br><span class="line">    if(_timer)&#123;</span><br><span class="line">        </span><br><span class="line">        [_timer invalidate];</span><br><span class="line">        _timer=nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后附上我的GitHub代码地址：<a href="https://github.com/Insfgg99x/FGGAutomaticScrollView" target="_blank" rel="external">FGGAutomaticScrollView</a>，欢迎pull request和star ~<br>以及我的个人博客：<a href="http://cgpointzero.top">CGPointZero</a>欢迎访问～<br><img src="http://upload-images.jianshu.io/upload_images/937405-e91a649f7a7df2a0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2016年最新版iOS App内购买详细指南]]></title>
      <url>http://cgpointzero.top/2016/09/07/in-app-purchase/</url>
      <content type="html"><![CDATA[<p>##摘要：</p>
<ul>
<li>本文讲述了如何创建App内购买项目？</li>
<li>如何添加沙盒App内购买测试帐号？</li>
<li>如何封装一个内购买的管理类？</li>
<li>如何在完成付款之后，保证有效的提供增值服务？<br>###如何创建内购买项目？<br>创建内购买之前，请确保已完成“协议、税务和银行业务”。打开iTunes Connect，进入app，选择”功能”-“App内购买项目”，点击”＋”创建一个内购买项目</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/937405-99d61a36a4c8d77e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>选择所属类型：<br><img src="http://upload-images.jianshu.io/upload_images/937405-19fa37f86b8d245e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>按照提示填写名称，定价，产品id，以及描述信息，内购商品列表截图。<br><img src="http://upload-images.jianshu.io/upload_images/937405-2389e241e444ff5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>需要注意产品id的规范，它必须由：<code>&quot;bundle identifier&quot;+编号</code>组成 如<code>xxx01</code>，其中<code>xxx</code>表示<code>bundle identifier</code>。<br>每个内购项目需要提供一个内购买商品列表截图，如：<br><img src="http://upload-images.jianshu.io/upload_images/937405-e36392c078eb248f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>创建完内购项目之后，我们需要一个沙盒测试帐号。</p>
<p>###如何创建沙盒测试帐号？<br>进入“用户和职能”，选择“沙箱测试技术员”，点击“＋”添加一个测试帐号：<br><img src="http://upload-images.jianshu.io/upload_images/937405-77bc12bf15c7406c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>按照提示，输入信息，创建测试帐号，用于内购买测试。接下来是代码部分。</p>
<p>###如何封装一个内购买管理类？<br>思路</p>
<ul>
<li>这个管理类需要有一个支付的调起接口，至少要一个产品id参数；</li>
<li>若是非消耗型商品，需要提供一个恢复已购买商品的接口；</li>
<li>要保证内购付完款之后，要告诉我们自己的服务器，我买了什么东西，而要做到这一点，我们又要考虑：<br>搞一个管理类：<code>@interface FCInAppPurchaseManager : NSObject</code><br>搞个单例类方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  单例类</span><br><span class="line"> *</span><br><span class="line"> *  @return 单例对象</span><br><span class="line"> */</span><br><span class="line">+(instancetype)sharedManager;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>搞一个购买商品的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  购买商品</span><br><span class="line"> *</span><br><span class="line"> *  @param identifier iTunes Connect商品ID</span><br><span class="line"> *  @param tradeId    交易id（自己服务器创建订单的交易id）</span><br><span class="line"> *  @param key        交易标识（自己服务器生成的key，防治杜撰交易）</span><br><span class="line"> */</span><br><span class="line">-(void)purchaseProductWithIdentifier:(NSString *)identifier tradeId:(NSString *)tradeId key:(NSString *)key;</span><br></pre></td></tr></table></figure></p>
<p>在商品列表界面购买商品时，调用上面这个接口，从自己服务器创建交易，获取交易id和key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line">    //创建交易</span><br><span class="line">    FCInnserPurchaseProductModel *model=_dataArray[indexPath.row];</span><br><span class="line">    FCFamousUser *currentUser=[[FCAccountSettings getCurrentAccountSetting] getCurrentUser];</span><br><span class="line">    NSString *token=[FCMainSettings getToken];</span><br><span class="line">    NSDictionary *params=@&#123;kAfterLoginToken:token,</span><br><span class="line">                           @&quot;userid&quot;:currentUser.userId,</span><br><span class="line">                           @&quot;no&quot;:@(currentUser.no),</span><br><span class="line">                           @&quot;productid&quot;:model.productId,</span><br><span class="line">                           @&quot;price&quot;:model.price,</span><br><span class="line">                           @&quot;coin&quot;:model.coin,</span><br><span class="line">                           @&quot;quantity&quot;:@1,</span><br><span class="line">                           @&quot;signature&quot;:[[NSUUID UUID] UUIDString],</span><br><span class="line">                           @&quot;channel&quot;:@&quot;ios&quot;,</span><br><span class="line">                           @&quot;device_type&quot;:@&quot;ios&quot;&#125;;</span><br><span class="line">    HUDShowLoading</span><br><span class="line">    [[FCWebServiceController sharedWebServiceController] sendRequestWithParameters:params action:@&quot;trade/create&quot; success:^(id json) &#123;</span><br><span class="line">        </span><br><span class="line">        if(![json isKindOfClass:[NSDictionary class]])&#123;</span><br><span class="line">            HUDError(kServerInnerError)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        HUDDismiss</span><br><span class="line">        NSString *tradeId=[[json objectForKey:@&quot;trade&quot;] objectForKey:@&quot;_id&quot;];</span><br><span class="line">        NSString *key=[[json objectForKey:@&quot;extras&quot;] objectForKey:@&quot;key&quot;];</span><br><span class="line">        //调起购买管理类的购买</span><br><span class="line">        [[FCInAppPurchaseManager sharedManager] purchaseProductWithIdentifier:model.identifier tradeId:tradeId key:key];</span><br><span class="line">        </span><br><span class="line">    &#125; failure:^(NSError *error) &#123;</span><br><span class="line">        HUDError(error.localizedDescription);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###内购买管理类的实现 <code>FCInAppPurchaseManager.m</code><br>首先要导入StoreKit框架：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;StoreKit/StoreKit.h&gt;</span><br></pre></td></tr></table></figure></p>
<p>单例类方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static FCInAppPurchaseManager *purchaseManager=nil;</span><br><span class="line">+(instancetype)sharedManager&#123;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        purchaseManager=[[FCInAppPurchaseManager alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return purchaseManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>搞一个拓展，加上一些私有属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface FCInAppPurchaseManager()&lt;SKProductsRequestDelegate,SKPaymentTransactionObserver&gt;</span><br><span class="line">/**</span><br><span class="line"> *  服务器生成的校验码</span><br><span class="line"> */</span><br><span class="line">@property(nonatomic,copy)NSString *key;</span><br><span class="line">/**</span><br><span class="line"> *  iTunes Connect上商品的标识符</span><br><span class="line"> */</span><br><span class="line">@property(nonatomic,copy)NSString *identifier;</span><br><span class="line">/**</span><br><span class="line"> *  服务器的交易编号</span><br><span class="line"> */</span><br><span class="line">@property(nonatomic,copy)NSString *tradeId;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>初始化方法中，添加监听：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(instancetype)init&#123;</span><br><span class="line">    </span><br><span class="line">    if(self=[super init])&#123;</span><br><span class="line">        </span><br><span class="line">        [[SKPaymentQueue defaultQueue] addTransactionObserver:self];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现购买商品的接口：保存交易id、key到本地的目的是，支付完成后，告诉服务器用户买了啥的这个过程是一个不确定的过程，有可能断网了，手机没电了、程序被终结了，程序bug崩溃了等不确定因素，一次要保留这一次的交易id、key，再次启动app时，我们的服务器没有拿着凭证去向苹果服务器验证交易信息苹果会自动调用监听购买结果的方法<code>paymentQueue : updatedTransactions :</code>，在这个方法中，完成上一次应该告诉我们服务器用户买了啥的任务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  购买商品</span><br><span class="line"> *</span><br><span class="line"> *  @param identifier 产品在iTunes connect中的标识符（HZSX.FriendCircle01 HZSX.FriendCircle02 HZSX.FriendCircle03 分别对应60圈币、180圈币 300圈币）</span><br><span class="line"> *  @param tradeId    交易编号（服务端生成的）</span><br><span class="line"> *  @param key        验证用的key（服务端生成）</span><br><span class="line"> */</span><br><span class="line">-(void)purchaseProductWithIdentifier:(NSString *)identifier tradeId:(NSString *)tradeId key:(NSString *)key&#123;</span><br><span class="line">    </span><br><span class="line">    if(![SKPaymentQueue canMakePayments])&#123;</span><br><span class="line">        </span><br><span class="line">        HUDError(@&quot;您的手机没有打开程序内付费购买&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(![identifier hasPrefix:@&quot;HZSX.FriendCircle&quot;])&#123;</span><br><span class="line">        </span><br><span class="line">        HUDError(@&quot;商品类型错误&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(kFCEmptyCheck(tradeId))&#123;</span><br><span class="line">        HUDError(@&quot;交易编号不能为空&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(kFCEmptyCheck(key))&#123;</span><br><span class="line">        HUDError(@&quot;缺少必要参数&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    _identifier=identifier;</span><br><span class="line">    _tradeId=tradeId;</span><br><span class="line">    _key=key;</span><br><span class="line">    //存到本地</span><br><span class="line">    NSString *token=[FCMainSettings getToken];</span><br><span class="line">    NSString *tradeId_key=[NSString stringWithFormat:@&quot;%@_tradeId&quot;,token];</span><br><span class="line">    NSString *tradeKey_key=[NSString stringWithFormat:@&quot;%@_key&quot;,token];</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] setObject:tradeId forKey:tradeId_key];</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] setObject:key forKey:tradeKey_key];</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line">    </span><br><span class="line">    NSSet *set=[NSSet setWithObject:identifier];</span><br><span class="line">    //发起购买商品的请求</span><br><span class="line">    SKProductsRequest *request=[[SKProductsRequest alloc] initWithProductIdentifiers:set];</span><br><span class="line">    request.delegate=self;</span><br><span class="line">    [request start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现StoreKit的代理方法：<br>#pragma mark - SKProductsRequestDelegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//收到的产品信息</span><br><span class="line">- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response&#123;</span><br><span class="line">    </span><br><span class="line">    if(response.products.count==0)&#123;</span><br><span class="line">        HUDError(@&quot;商品信息错误&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    SKProduct *product=response.products.lastObject;</span><br><span class="line">    SKPayment *payment=[SKPayment paymentWithProduct:product];</span><br><span class="line">    [[SKPaymentQueue defaultQueue] addPayment:payment];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#pragma mark - SKRequestDelegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(void)request:(SKRequest *)request didFailWithError:(NSError *)error&#123;</span><br><span class="line">    </span><br><span class="line">    HUDError(error.localizedDescription);</span><br><span class="line">&#125;</span><br><span class="line">-(void)requestDidFinish:(SKRequest *)request&#123;</span><br><span class="line">    </span><br><span class="line">    HUDDismiss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>监听购买结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 监听购买结果(若购买时，退出了app，苹果会在app启动时，自动调用这个方法)</span><br><span class="line">-(void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray *)transactions&#123;</span><br><span class="line">    </span><br><span class="line">    if(transactions.count==0!transactions)&#123;</span><br><span class="line">        </span><br><span class="line">        HUDError(@&quot;获取不到购买结果&quot;)</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    SKPaymentTransaction *transaction=transactions.lastObject;</span><br><span class="line">    switch (transaction.transactionState)</span><br><span class="line">    &#123;</span><br><span class="line">        case SKPaymentTransactionStatePurchased:&#123;//交易完成</span><br><span class="line">            </span><br><span class="line">            [self recordTransaction:transaction];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case SKPaymentTransactionStateFailed:&#123;//交易失败</span><br><span class="line">        </span><br><span class="line">            [self failedTransaction:transaction];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case SKPaymentTransactionStateRestored://已经购买过该商品</span><br><span class="line">            [self restoreTransactions];</span><br><span class="line">            break;</span><br><span class="line">        case SKPaymentTransactionStatePurchasing: //商品添加进列表</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么问题来了？</p>
<p>###为什么不把交易完成后，告诉自己服务器，买了什么，这部分业务抽离出来呢？<br>考虑到从调起支付到支付结果（成功、失败等）需要<code>几秒甚至十几秒</code>，在这段时间内，用户可能离开了当前界面，<br>而苹果购买的结果回调时，用户不在当前界面就告诉不了我们的服务器，用户买了啥啥啥。<br>因此我把购买完成，告诉服务器的这部分逻辑也写进了这个管理类里面。这样，用户无论是否离开当前页面，只要支付成功了，就能调用告诉服务器用户买了啥的逻辑。</p>
<p>告诉服务器用户买了啥：同时将交易id、交易key、凭证<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - 请求服务端，记录交易 告诉服务器我买了什么</span><br><span class="line">-(void)recordTransaction:(SKPaymentTransaction *)transaction&#123;</span><br><span class="line">    </span><br><span class="line">    //结束交易</span><br><span class="line">    [[SKPaymentQueue defaultQueue] finishTransaction: transaction];</span><br><span class="line">    </span><br><span class="line">    NSString *token=[FCMainSettings getToken];</span><br><span class="line">    NSString *tradeId_key=[NSString stringWithFormat:@&quot;%@_tradeId&quot;,token];</span><br><span class="line">    NSString *tradeKey_key=[NSString stringWithFormat:@&quot;%@_key&quot;,token];</span><br><span class="line">    if(kFCEmptyCheck(_tradeId))&#123;</span><br><span class="line">        _tradeId=[[NSUserDefaults standardUserDefaults] objectForKey:tradeId_key];</span><br><span class="line">    &#125;</span><br><span class="line">    if(kFCEmptyCheck(_key))&#123;</span><br><span class="line">        _key=[[NSUserDefaults standardUserDefaults] objectForKey:tradeKey_key];</span><br><span class="line">    &#125;</span><br><span class="line">    //获取苹果返回的支付凭证</span><br><span class="line">    NSURL *receiptURL=[[NSBundle mainBundle] appStoreReceiptURL];</span><br><span class="line">    NSData *receiptData=[NSData dataWithContentsOfURL:receiptURL];</span><br><span class="line">    if(!receiptData)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *base64_receipt=[[receiptData base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithLineFeed]</span><br><span class="line">                              stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];</span><br><span class="line">    if(kFCEmptyCheck(base64_receipt))&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //sign=MD5(tradeid=tradeid&amp;salt=mrpyp-2016&amp;key=key)</span><br><span class="line">    NSString *components=[[NSString stringWithFormat:@&quot;tradeid=%@&amp;salt=mrpyp-2016&amp;key=%@&quot;,_tradeId,_key]</span><br><span class="line">                          stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];</span><br><span class="line">    //NSString *rsa_components=[[RSA encryptString:components publicKey:kInAppPurchaseRSAPublicKey]</span><br><span class="line">    //                          stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];</span><br><span class="line">    NSString *md5_componets=[components MD5Hash];</span><br><span class="line">    if(kFCEmptyCheck(token)kFCEmptyCheck(_tradeId)kFCEmptyCheck(md5_componets))&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSDictionary *params=@&#123;kAfterLoginToken:token,</span><br><span class="line">                           @&quot;sign&quot;:md5_componets,</span><br><span class="line">                           @&quot;tradeid&quot;:_tradeId,</span><br><span class="line">                           @&quot;receipt&quot;:base64_receipt,</span><br><span class="line">                           @&quot;key&quot;:_key&#125;;</span><br><span class="line">    [self tellServerBuySuccessWithdTradeInfo:params];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>告诉服务器，我们买了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  告诉服务器购买成功了</span><br><span class="line"> *</span><br><span class="line"> *  @param tradeInfo       交易信息</span><br><span class="line"> *  @param destinationPath 存放交易信息的文件路径</span><br><span class="line"> */</span><br><span class="line">-(void)tellServerBuySuccessWithdTradeInfo:(NSDictionary *)tradeInfo/* destionationPath:(NSString *)destinationPath*/&#123;</span><br><span class="line">    </span><br><span class="line">    [[FCWebServiceController sharedWebServiceController] sendRequestWithParameters:tradeInfo action:@&quot;pay/ios_receipt_verify&quot; success:^(id json) &#123;</span><br><span class="line">        </span><br><span class="line">        if(![json isKindOfClass:[NSDictionary class]])&#123;</span><br><span class="line">            HUDError(kServerInnerError)</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        BOOL result=[[json objectForKey:@&quot;result&quot;] boolValue];</span><br><span class="line">        if(!result)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;验证成功&quot;);</span><br><span class="line">        //显示购买成功的视图</span><br><span class="line">        //[self showBuySuccessViewWithCoin:60];</span><br><span class="line">        </span><br><span class="line">    &#125; failure:^(NSError *error) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,error.localizedDescription);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###恢复已购买的商品<br>若你购买的商品类型是<code>非消耗型</code>的，在用户切换帐号，换手机等情景下，恢复已购买的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//恢复购买的装备</span><br><span class="line">-(void)restoreTransactions&#123;</span><br><span class="line"></span><br><span class="line">    [[SKPaymentQueue defaultQueue] restoreCompletedTransactions];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并实现恢复购买的代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//恢复购买的装备成功</span><br><span class="line">-(void)paymentQueueRestoreCompletedTransactionsFinished: (SKPaymentTransaction *)transaction&#123;</span><br><span class="line">    </span><br><span class="line">    if(!transaction)</span><br><span class="line">        return;</span><br><span class="line">    [self paymentQueue:[SKPaymentQueue defaultQueue] updatedTransactions:@[transaction]];</span><br><span class="line">&#125;</span><br><span class="line">//恢复购买的装备失败</span><br><span class="line">-(void)paymentQueue:(SKPaymentQueue *) paymentQueue restoreCompletedTransactionsFailedWithError:(NSError *)error&#123;</span><br><span class="line">    </span><br><span class="line">    HUDError(error.localizedDescription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后在<code>dealloc</code>方法中注销监听:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(void)dealloc&#123;</span><br><span class="line">    </span><br><span class="line">    [[SKPaymentQueue defaultQueue] removeTransactionObserver:self];//解除监听</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###测试内购买<br>内购买的代码已经写好了，内购项目也新建了，沙盒测试帐号也有了，现在可以动手测试内购买了。</p>
<ul>
<li>手机打开App Store，选择第一个tab<code>精品推荐</code>，滚动到最底部，点击自己的Apple ID，在弹出的框中，选择<code>注销</code>。</li>
<li>打开我们自己的app，进入内购买<code>商品列表页面</code>，点一个商品，发起购买。</li>
<li>在登陆的弹框中选择<code>使用现有的Apple ID</code>，在登陆iTunes connect的弹框中，输入前面注册的<code>沙盒测试帐号</code></li>
<li>在购买信息的弹框中选择<code>购买</code><br><img src="http://upload-images.jianshu.io/upload_images/937405-e42a3ba654fcb492.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>购买完成，前往<code>我的帐户</code>，查看充值记录，验证服务器是否纪录此次交易。<br>###提交审核<br>若你的app时第一次加入内购买，则，app内购项目也要一并提交<br><img src="http://upload-images.jianshu.io/upload_images/937405-2157998701de688e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>至此，内购买集成结束，欢迎关注我的个人博客：<a href="http://cgpointzero.top">CGPointZero</a><br><img src="http://upload-images.jianshu.io/upload_images/937405-e91a649f7a7df2a0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用NSURLConnection封装一个断点续传后台下载的轻量级下载工具]]></title>
      <url>http://cgpointzero.top/2016/09/06/downloader/</url>
      <content type="html"><![CDATA[<p>###摘要</p>
<ul>
<li>本文讲述，用NSURLConnection封装一个断点下载，支持后台下载的完整的下载工具。<br>###效果图<br><img src="http://upload-images.jianshu.io/upload_images/937405-a515886852667cb1.gif?imageMogr2/auto-orient/strip" alt="效果图"></li>
</ul>
<p>###用法示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[[FGGDownloadManager shredManager] downloadWithUrlString:model.url toPath:model.destinationPath process:^(float progress, NSString *sizeString, NSString *speedString) &#123;</span><br><span class="line">//更新进度条的进度值</span><br><span class="line">weakCell.progressView.progress=progress;</span><br><span class="line">//更新进度值文字</span><br><span class="line">weakCell.progressLabel.text=[NSString stringWithFormat:@&quot;%.2f%%&quot;,progress*100];</span><br><span class="line">//更新文件已下载的大小</span><br><span class="line">weakCell.sizeLabel.text=sizeString;</span><br><span class="line">//显示网速</span><br><span class="line">weakCell.speedLabel.text=speedString;</span><br><span class="line">if(speedString)</span><br><span class="line">weakCell.speedLabel.hidden=NO;</span><br><span class="line"></span><br><span class="line">&#125; completion:^&#123;</span><br><span class="line">[sender setTitle:@&quot;完成&quot; forState:UIControlStateNormal];</span><br><span class="line">sender.enabled=NO;</span><br><span class="line">weakCell.speedLabel.hidden=YES;</span><br><span class="line">UIAlertView *alert=[[UIAlertView alloc]initWithTitle:@&quot;提示&quot; message:[NSString stringWithFormat:@&quot;%@下载完成✅&quot;,model.name] delegate:nil cancelButtonTitle:@&quot;好&quot; otherButtonTitles:nil, nil];</span><br><span class="line">[alert show];</span><br><span class="line"></span><br><span class="line">&#125; failure:^(NSError *error) &#123;</span><br><span class="line">[[FGGDownloadManager shredManager] cancelDownloadTask:model.url];</span><br><span class="line">[sender setTitle:@&quot;恢复&quot; forState:UIControlStateNormal];</span><br><span class="line">weakCell.speedLabel.hidden=YES;</span><br><span class="line">UIAlertView *alert=[[UIAlertView alloc]initWithTitle:@&quot;Error&quot; message:error.localizedDescription delegate:nil cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil, nil];</span><br><span class="line">[alert show];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>###思路</p>
<ul>
<li>搞一个下载类，负责一个下载任务；</li>
<li>搞一个下载管理类，负责下载队列；</li>
<li>在程序进入后台时，开启后台下载；</li>
<li>在程序被终结时取消所有下载并保存下载进度；</li>
<li>当程序启动时，加载上次下载进度；</li>
</ul>
<p>###下载类 FGGDownloader.h<br>FGGDownloader遵循NSURLConnection的一些协议:<br><code>@interface FGGDownloader : NSObject&lt;NSURLConnectionDataDelegate,NSURLConnectionDelegate&gt;</code><br>接下来定义三个代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^ProcessHandle)(float progress,NSString *sizeString,NSString *speedString);</span><br><span class="line">typedef void (^CompletionHandle)();</span><br><span class="line">typedef void (^FailureHandle)(NSError *error);</span><br></pre></td></tr></table></figure>
<p>然后声明三个只读属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//下载过程中回调的代码块，会多次调用</span><br><span class="line">@property(nonatomic,copy,readonly)ProcessHandle process;</span><br><span class="line">//下载完成回调的代码块</span><br><span class="line">@property(nonatomic,copy,readonly)CompletionHandle completion;</span><br><span class="line">//下载失败的回调代码块</span><br><span class="line">@property(nonatomic,copy,readonly)FailureHandle failure;</span><br></pre></td></tr></table></figure></p>
<p>写一个快速实例的类方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(instancetype)downloader;</span><br></pre></td></tr></table></figure></p>
<p>搞一个下载的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  断点下载</span><br><span class="line">*</span><br><span class="line">*  @param urlString        下载的链接</span><br><span class="line">*  @param destinationPath  下载的文件的保存路径</span><br><span class="line">*  @param  process         下载过程中回调的代码块，会多次调用</span><br><span class="line">*  @param  completion      下载完成回调的代码块</span><br><span class="line">*  @param  failure         下载失败的回调代码块</span><br><span class="line">*/</span><br><span class="line">-(void)downloadWithUrlString:(NSString *)urlString</span><br><span class="line">toPath:(NSString *)destinationPath</span><br><span class="line">process:(ProcessHandle)process</span><br><span class="line">completion:(CompletionHandle)completion</span><br><span class="line">failure:(FailureHandle)failure;</span><br></pre></td></tr></table></figure></p>
<p>搞一个取消下载的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  取消下载</span><br><span class="line">*/</span><br><span class="line">-(void)cancel;</span><br></pre></td></tr></table></figure></p>
<p>程序启动的时候要加载上一次的下载进度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 获取上一次的下载进度</span><br><span class="line">*/</span><br><span class="line">+(float)lastProgress:(NSString *)url;</span><br></pre></td></tr></table></figure></p>
<p>需要在界面上显示文件下载了的大小，文件总大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**获取文件已下载的大小和总大小,格式为:已经下载的大小/文件总大小,如：12.00M/100.00M。</span><br><span class="line">*</span><br><span class="line">* @param url 下载链接</span><br><span class="line">*/</span><br><span class="line">+(NSString *)filesSize:(NSString *)url;</span><br></pre></td></tr></table></figure></p>
<p>搞三个通知，因为下载管理类要用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  下载完成的通知名</span><br><span class="line">*/</span><br><span class="line">static NSString *const FGGDownloadTaskDidFinishDownloadingNotification=@&quot;FGGDownloadTaskDidFinishDownloadingNotification&quot;;</span><br><span class="line">/**</span><br><span class="line">*  系统存储空间不足的通知名</span><br><span class="line">*/</span><br><span class="line">static NSString *const FGGInsufficientSystemSpaceNotification=@&quot;FGGInsufficientSystemSpaceNotification&quot;;</span><br><span class="line">/**</span><br><span class="line">*  下载进度改变的通知</span><br><span class="line">*/</span><br><span class="line">static NSString *const FGGProgressDidChangeNotificaiton=@&quot;FGGProgressDidChangeNotificaiton&quot;;</span><br></pre></td></tr></table></figure></p>
<p>###下载类的实现 FGGDownloader.m<br>大文件下载，要遵循低内存占用，因此我们要有一个文件读写句柄：<code>NSFileHandle</code>，以及一些储放下载位置、下载路径、链接等一些东西的成员变量。</p>
<p><pre><br>说明一下，<code>_timer</code>是为了获取网速近似值，没0.5秒计算文件增长的大小，取网速平均值.<br>这里有个假设：假设文件读写不占用时间，而在这0.5秒内文件的增量直接反应网速。<br></pre><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@implementation FGGDownloader&#123;</span><br><span class="line"></span><br><span class="line">NSString        *_url_string;</span><br><span class="line">NSString        *_destination_path;</span><br><span class="line">NSFileHandle    *_writeHandle;</span><br><span class="line">NSURLConnection *_con;</span><br><span class="line">NSUInteger       _lastSize;</span><br><span class="line">NSUInteger       _growth;</span><br><span class="line">NSTimer         *_timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>快速实例化的类方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+(instancetype)downloader&#123;</span><br><span class="line"></span><br><span class="line">return [[[self class] alloc]init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(instancetype)init&#123;</span><br><span class="line"></span><br><span class="line">if(self=[super init])&#123;</span><br><span class="line"></span><br><span class="line">//每0.5秒计算一次文件大小增加部分的尺寸</span><br><span class="line">_timer=[NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(getGrowthSize) userInfo:nil repeats:YES];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>计算文件没0.5秒的增量，以计算网速近似值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//计算一次文件大小增加部分的尺寸，以计算网速近似值</span><br><span class="line">-(void)getGrowthSize</span><br><span class="line">&#123;</span><br><span class="line">NSUInteger size=[[[[NSFileManager defaultManager] attributesOfItemAtPath:_destination_path error:nil] objectForKey:NSFileSize] integerValue];</span><br><span class="line">_growth=size-_lastSize;</span><br><span class="line">_lastSize=size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键方法，下载接口方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  断点下载</span><br><span class="line">*</span><br><span class="line">*  @param urlString        下载的链接</span><br><span class="line">*  @param destinationPath  下载的文件的保存路径</span><br><span class="line">*  @param  process         下载过程中回调的代码块，会多次调用</span><br><span class="line">*  @param  completion      下载完成回调的代码块</span><br><span class="line">*  @param  failure         下载失败的回调代码块</span><br><span class="line">*/</span><br><span class="line">-(void)downloadWithUrlString:(NSString *)urlString toPath:(NSString *)destinationPath process:(ProcessHandle)process completion:(CompletionHandle)completion failure:(FailureHandle)failure&#123;</span><br><span class="line"></span><br><span class="line">if(urlString&amp;&amp;destinationPath)&#123;</span><br><span class="line"></span><br><span class="line">_url_string=urlString;</span><br><span class="line">_destination_path=destinationPath;</span><br><span class="line">_process=process;</span><br><span class="line">_completion=completion;</span><br><span class="line">_failure=failure;</span><br><span class="line"></span><br><span class="line">NSURL *url=[NSURL URLWithString:urlString];</span><br><span class="line">NSMutableURLRequest *request=[NSMutableURLRequest requestWithURL:url];</span><br><span class="line">NSFileManager *fileManager=[NSFileManager defaultManager];</span><br><span class="line">BOOL fileExist=[fileManager fileExistsAtPath:destinationPath];</span><br><span class="line">if(fileExist)&#123;</span><br><span class="line"></span><br><span class="line">NSUInteger length=[[[fileManager attributesOfItemAtPath:destinationPath error:nil] objectForKey:NSFileSize] integerValue];</span><br><span class="line">NSString *rangeString=[NSString stringWithFormat:@&quot;bytes=%ld-&quot;,length];</span><br><span class="line">[request setValue:rangeString forHTTPHeaderField:@&quot;Range&quot;];</span><br><span class="line">&#125;</span><br><span class="line">_con=[NSURLConnection connectionWithRequest:request delegate:self];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>取消下载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  取消下载</span><br><span class="line">*/</span><br><span class="line">-(void)cancel&#123;</span><br><span class="line"></span><br><span class="line">[self.con cancel];</span><br><span class="line">self.con=nil;</span><br><span class="line">if(_timer)&#123;</span><br><span class="line"></span><br><span class="line">[_timer invalidate];</span><br><span class="line">_timer=nil;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序每次启动都要获取上次的下载进度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 获取上一次的下载进度</span><br><span class="line">*/</span><br><span class="line">+(float)lastProgress:(NSString *)url&#123;</span><br><span class="line"></span><br><span class="line">if(url)</span><br><span class="line">return [[NSUserDefaults standardUserDefaults]floatForKey:[NSString stringWithFormat:@&quot;%@progress&quot;,url]];</span><br><span class="line">return 0.0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过下载链接url获取文件的大小信息（当前大小/总大小 组成的字符串）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**获取文件已下载的大小和总大小,格式为:已经下载的大小/文件总大小,如：12.00M/100.00M</span><br><span class="line">*/</span><br><span class="line">+(NSString *)filesSize:(NSString *)url&#123;</span><br><span class="line"></span><br><span class="line">NSString *totalLebgthKey=[NSString stringWithFormat:@&quot;%@totalLength&quot;,url];</span><br><span class="line">NSUserDefaults *usd=[NSUserDefaults standardUserDefaults];</span><br><span class="line">NSUInteger totalLength=[usd integerForKey:totalLebgthKey];</span><br><span class="line">if(totalLength==0)&#123;</span><br><span class="line"></span><br><span class="line">return @&quot;0.00K/0.00K&quot;;</span><br><span class="line">&#125;</span><br><span class="line">NSString *progressKey=[NSString stringWithFormat:@&quot;%@progress&quot;,url];</span><br><span class="line">float progress=[[NSUserDefaults standardUserDefaults] floatForKey:progressKey];</span><br><span class="line">NSUInteger currentLength=progress*totalLength;</span><br><span class="line"></span><br><span class="line">NSString *currentSize=[self convertSize:currentLength];</span><br><span class="line">NSString *totalSize=[self convertSize:totalLength];</span><br><span class="line">return [NSString stringWithFormat:@&quot;%@/%@&quot;,currentSize,totalSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是个工具方法，把文件的长度(字节)转成字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 计算缓存的占用存储大小</span><br><span class="line">*</span><br><span class="line">* @prama length  文件大小</span><br><span class="line">*/</span><br><span class="line">+(NSString *)convertSize:(NSUInteger)length</span><br><span class="line">&#123;</span><br><span class="line">if(length&lt;1024)</span><br><span class="line">return [NSString stringWithFormat:@&quot;%ldB&quot;,(NSUInteger)length];</span><br><span class="line">else if(length&gt;=1024&amp;&amp;length&lt;1024*1024)</span><br><span class="line">return [NSString stringWithFormat:@&quot;%.0fK&quot;,(float)length/1024];</span><br><span class="line">else if(length &gt;=1024*1024&amp;&amp;length&lt;1024*1024*1024)</span><br><span class="line">return [NSString stringWithFormat:@&quot;%.1fM&quot;,(float)length/(1024*1024)];</span><br><span class="line">else</span><br><span class="line">return [NSString stringWithFormat:@&quot;%.1fG&quot;,(float)length/(1024*1024*1024)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下载过程可能会存储空间不足，若不做处理，会导致crash，因此每次句柄写文件时，都要判断存储空间是否足够：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  获取系统可用存储空间</span><br><span class="line">*</span><br><span class="line">*  @return 系统空用存储空间，单位：字节</span><br><span class="line">*/</span><br><span class="line">-(NSUInteger)systemFreeSpace&#123;</span><br><span class="line"></span><br><span class="line">NSString *docPath=[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">NSDictionary *dict=[[NSFileManager defaultManager] attributesOfFileSystemForPath:docPath error:nil];</span><br><span class="line">return [[dict objectForKey:NSFileSystemFreeSize] integerValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###下面是NSURLConnect的代理和数据源<br>下载失败，回调error block：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - NSURLConnection</span><br><span class="line">/**</span><br><span class="line">* 下载失败</span><br><span class="line">*/</span><br><span class="line">-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error&#123;</span><br><span class="line"></span><br><span class="line">if(_failure)</span><br><span class="line">_failure(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在接受到响应请求的代理方法中存储文件中大小，以及初始化文件读写句柄<code>_writeHandle</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 接收到响应请求</span><br><span class="line">*/</span><br><span class="line">-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123;</span><br><span class="line"></span><br><span class="line">NSString *key=[NSString stringWithFormat:@&quot;%@totalLength&quot;,_url_string];</span><br><span class="line">NSUserDefaults *usd=[NSUserDefaults standardUserDefaults];</span><br><span class="line">NSUInteger totalLength=[usd integerForKey:key];</span><br><span class="line">if(totalLength==0)&#123;</span><br><span class="line"></span><br><span class="line">[usd setInteger:response.expectedContentLength forKey:key];</span><br><span class="line">[usd synchronize];</span><br><span class="line">&#125;</span><br><span class="line">NSFileManager *fileManager=[NSFileManager defaultManager];</span><br><span class="line">BOOL fileExist=[fileManager fileExistsAtPath:_destination_path];</span><br><span class="line">if(!fileExist)</span><br><span class="line">[fileManager createFileAtPath:_destination_path contents:nil attributes:nil];</span><br><span class="line">_writeHandle=[NSFileHandle fileHandleForWritingAtPath:_destination_path];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下载过程的接收数据的回调，处理计算网速、下载进度、文件大小信息，存档当前大小等操作，最后回调<b><i>网速</i></b>，文件大小/总大小字符串，<b><i>下载进度</i></b>信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 下载过程，会多次调用</span><br><span class="line">*/</span><br><span class="line">-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data&#123;</span><br><span class="line"></span><br><span class="line">[_writeHandle seekToEndOfFile];</span><br><span class="line"></span><br><span class="line">NSUInteger freeSpace=[self systemFreeSpace];</span><br><span class="line">if(freeSpace&lt;1024*1024*20)&#123;</span><br><span class="line"></span><br><span class="line">UIAlertController *alertController=[UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:@&quot;系统可用存储空间不足20M&quot; preferredStyle:UIAlertControllerStyleAlert];</span><br><span class="line">UIAlertAction *confirm=[UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:nil];</span><br><span class="line">[alertController addAction:confirm];</span><br><span class="line">[[UIApplication sharedApplication].keyWindow.rootViewController presentViewController:alertController animated:YES completion:nil];</span><br><span class="line">//发送系统存储空间不足的通知,用户可自行注册该通知，收到通知时，暂停下载，并更新界面</span><br><span class="line">[[NSNotificationCenter defaultCenter] postNotificationName:FGGInsufficientSystemSpaceNotification object:nil userInfo:@&#123;@&quot;urlString&quot;:_url_string&#125;];</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">[_writeHandle writeData:data];</span><br><span class="line">NSUInteger length=[[[[NSFileManager defaultManager] attributesOfItemAtPath:_destination_path error:nil] objectForKey:NSFileSize] integerValue];</span><br><span class="line">NSString *key=[NSString stringWithFormat:@&quot;%@totalLength&quot;,_url_string];</span><br><span class="line">NSUInteger totalLength=[[NSUserDefaults standardUserDefaults] integerForKey:key];</span><br><span class="line"></span><br><span class="line">//计算下载进度</span><br><span class="line">float progress=(float)length/totalLength;</span><br><span class="line"></span><br><span class="line">[[NSUserDefaults standardUserDefaults]setFloat:progress forKey:[NSString stringWithFormat:@&quot;%@progress&quot;,_url_string]];</span><br><span class="line">[[NSUserDefaults standardUserDefaults] synchronize];</span><br><span class="line"></span><br><span class="line">//获取文件大小，格式为：格式为:已经下载的大小/文件总大小,如：12.00M/100.00M</span><br><span class="line">NSString *sizeString=[FGGDownloader filesSize:_url_string];</span><br><span class="line"></span><br><span class="line">//发送进度改变的通知(一般情况下不需要用到，只有在触发下载与显示下载进度在不同界面的时候才会用到)</span><br><span class="line">NSDictionary *userInfo=@&#123;@&quot;url&quot;:_url_string,@&quot;progress&quot;:@(progress),@&quot;sizeString&quot;:sizeString&#125;;</span><br><span class="line">[[NSNotificationCenter defaultCenter] postNotificationName:FGGProgressDidChangeNotificaiton object:nil userInfo:userInfo];</span><br><span class="line"></span><br><span class="line">//计算网速</span><br><span class="line">NSString *speedString=@&quot;0.00Kb/s&quot;;</span><br><span class="line">NSString *growString=[FGGDownloader convertSize:_growth*(1.0/0.1)];</span><br><span class="line">speedString=[NSString stringWithFormat:@&quot;%@/s&quot;,growString];</span><br><span class="line"></span><br><span class="line">//回调下载过程中的代码块</span><br><span class="line">if(_process)</span><br><span class="line">_process(progress,sizeString,speedString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下载完成，发送通知，回调下载完成的代码块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 下载完成</span><br><span class="line">*/</span><br><span class="line">-(void)connectionDidFinishLoading:(NSURLConnection *)connection&#123;</span><br><span class="line"></span><br><span class="line">[[NSNotificationCenter defaultCenter] postNotificationName:FGGDownloadTaskDidFinishDownloadingNotification object:nil userInfo:@&#123;@&quot;urlString&quot;:_url_string&#125;];</span><br><span class="line">if(_completion)</span><br><span class="line">_completion();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###下载管理类 FGGDownloadManager.h<br>首先要导入下载类：<code>#import &quot;FGGDownloader.h&quot;</code><br>单例接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(instancetype)shredManager;</span><br></pre></td></tr></table></figure></p>
<p>同样有添加下载任务的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  断点下载</span><br><span class="line">*</span><br><span class="line">*  @param urlString        下载的链接</span><br><span class="line">*  @param destinationPath  下载的文件的保存路径</span><br><span class="line">*  @param  process         下载过程中回调的代码块，会多次调用</span><br><span class="line">*  @param  completion      下载完成回调的代码块</span><br><span class="line">*  @param  failure         下载失败的回调代码块</span><br><span class="line">*/</span><br><span class="line">-(void)downloadWithUrlString:(NSString *)urlString</span><br><span class="line">toPath:(NSString *)destinationPath</span><br><span class="line">process:(ProcessHandle)process</span><br><span class="line">completion:(CompletionHandle)completion</span><br><span class="line">failure:(FailureHandle)failure;</span><br></pre></td></tr></table></figure></p>
<p>管理类自然可以暂停指定的某个下载，根据某个下载链接url，暂停某个下载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  暂停下载</span><br><span class="line">*</span><br><span class="line">*  @param url 下载的链接</span><br><span class="line">*/</span><br><span class="line">-(void)cancelDownloadTask:(NSString *)url;</span><br></pre></td></tr></table></figure></p>
<p>管理类可以暂停所有下载任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  暂停所有下载</span><br><span class="line">*/</span><br><span class="line">-(void)cancelAllTasks;</span><br></pre></td></tr></table></figure></p>
<p>管理类可以彻底移除某个下载任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  彻底移除下载任务</span><br><span class="line">*</span><br><span class="line">*  @param url  下载链接</span><br><span class="line">*  @param path 文件路径</span><br><span class="line">*/</span><br><span class="line">-(void)removeForUrl:(NSString *)url file:(NSString *)path;</span><br></pre></td></tr></table></figure></p>
<p>当然管理类可以根据下载链接url获取上一次的下载进度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  获取上一次的下载进度</span><br><span class="line">*</span><br><span class="line">*  @param url 下载链接</span><br><span class="line">*</span><br><span class="line">*  @return 下载进度</span><br><span class="line">*/</span><br><span class="line">-(float)lastProgress:(NSString *)url;</span><br></pre></td></tr></table></figure></p>
<p>以及获取文件大小信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  获取文件已下载的大小和总大小,格式为:已经下载的大小/文件总大小,如：12.00M/100.00M。</span><br><span class="line">*</span><br><span class="line">*  @param url 下载链接</span><br><span class="line">*</span><br><span class="line">*  @return 有文件大小及总大小组成的字符串</span><br><span class="line">*/</span><br><span class="line">-(NSString *)filesSize:(NSString *)url;</span><br></pre></td></tr></table></figure></p>
<p>###管理类的实现 FGGDownloadManager.m</p>
<ul>
<li>在这里，我们搞了一个队列，设置了同时最多允许多少个下载任务。</li>
<li>超过最大下载任务后，添加下载任务将会被添加进入下载任务队列，处于等待模式。</li>
<li>当当前正在进行的下载任务数小于允许最大同时下载任务数时，队列中的一个下载任务出列（遵循先入列的先出列）。</li>
</ul>
<p>根据逻辑，我定制了以下成员变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@implementation FGGDownloadManager&#123;</span><br><span class="line"></span><br><span class="line">NSMutableDictionary         *_taskDict;</span><br><span class="line">/**</span><br><span class="line">*  排队对列</span><br><span class="line">*/</span><br><span class="line">NSMutableArray              *_queue;</span><br><span class="line">/**</span><br><span class="line">*  后台进程id</span><br><span class="line">*/</span><br><span class="line">UIBackgroundTaskIdentifier  _backgroudTaskId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>单例方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+(instancetype)shredManager</span><br><span class="line">&#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">mgr=[[FGGDownloadManager alloc]init];</span><br><span class="line">&#125;);</span><br><span class="line">return mgr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化的时候，注册app进入后台，app会到前台，被终结等，以及系统内存不足的通知：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-(instancetype)init&#123;</span><br><span class="line"></span><br><span class="line">if(self=[super init])&#123;</span><br><span class="line"></span><br><span class="line">_taskDict=[NSMutableDictionary dictionary];</span><br><span class="line">_queue=[NSMutableArray array];</span><br><span class="line">_backgroudTaskId=UIBackgroundTaskInvalid;</span><br><span class="line">//注册系统内存不足的通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(systemSpaceInsufficient:) name:FGGInsufficientSystemSpaceNotification object:nil];</span><br><span class="line">//注册程序下载完成的通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(downloadTaskDidFinishDownloading:) name:FGGDownloadTaskDidFinishDownloadingNotification object:nil];</span><br><span class="line">//注册程序即将失去焦点的通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(downloadTaskWillResign:) name:UIApplicationWillResignActiveNotification object:nil];</span><br><span class="line">//注册程序获得焦点的通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(downloadTaskDidBecomActive:) name:UIApplicationDidBecomeActiveNotification object:nil];</span><br><span class="line">//注册程序即将被终结的通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(downloadTaskWillBeTerminate:) name:UIApplicationWillTerminateNotification object:nil];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>收到系统内存不足的通知时，取消下载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  收到系统存储空间不足的通知调用的方法</span><br><span class="line">*</span><br><span class="line">*  @param sender 系统存储空间不足的通知</span><br><span class="line">*/</span><br><span class="line">-(void)systemSpaceInsufficient:(NSNotification *)sender&#123;</span><br><span class="line"></span><br><span class="line">NSString *urlString=[sender.userInfo objectForKey:@&quot;urlString&quot;];</span><br><span class="line">[[FGGDownloadManager shredManager] cancelDownloadTask:urlString];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序即将失去焦点，开启后台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  收到程序即将失去焦点的通知，开启后台运行</span><br><span class="line">*</span><br><span class="line">*  @param sender 通知</span><br><span class="line">*/</span><br><span class="line">-(void)downloadTaskWillResign:(NSNotification *)sender&#123;</span><br><span class="line"></span><br><span class="line">if(_taskDict.count&gt;0)&#123;</span><br><span class="line"></span><br><span class="line">_backgroudTaskId=[[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序重新获得焦点时，关闭后台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  收到程序重新得到焦点的通知，关闭后台</span><br><span class="line">*</span><br><span class="line">*  @param sender 通知</span><br><span class="line">*/</span><br><span class="line">-(void)downloadTaskDidBecomActive:(NSNotification *)sender&#123;</span><br><span class="line"></span><br><span class="line">if(_backgroudTaskId!=UIBackgroundTaskInvalid)&#123;</span><br><span class="line"></span><br><span class="line">[[UIApplication sharedApplication] endBackgroundTask:_backgroudTaskId];</span><br><span class="line">_backgroudTaskId=UIBackgroundTaskInvalid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序即将被终结时，取消所有下载任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  程序将要结束时，取消下载</span><br><span class="line">*</span><br><span class="line">*  @param sender 通知</span><br><span class="line">*/</span><br><span class="line">-(void)downloadTaskWillBeTerminate:(NSNotification *)sender&#123;</span><br><span class="line"></span><br><span class="line">[[FGGDownloadManager shredManager] cancelAllTasks];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>收到下载完成的通知时，从排队队列中取出一个任务出列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  下载完成通知调用的方法</span><br><span class="line">*</span><br><span class="line">*  @param sender 通知</span><br><span class="line">*/</span><br><span class="line">-(void)downloadTaskDidFinishDownloading:(NSNotification *)sender&#123;</span><br><span class="line"></span><br><span class="line">//下载完成后，从任务列表中移除下载任务，若总任务数小于最大同时下载任务数，</span><br><span class="line">//则从排队对列中取出一个任务，进入下载</span><br><span class="line">NSString *urlString=[sender.userInfo objectForKey:@&quot;urlString&quot;];</span><br><span class="line">[_taskDict removeObjectForKey:urlString];</span><br><span class="line">if(_taskDict.count&lt;kFGGDwonloadMaxTaskCount)&#123;</span><br><span class="line"></span><br><span class="line">if(_queue.count&gt;0)&#123;</span><br><span class="line"></span><br><span class="line">NSDictionary *first=[_queue objectAtIndex:0];</span><br><span class="line"></span><br><span class="line">[self downloadWithUrlString:first[@&quot;urlString&quot;]</span><br><span class="line">toPath:first[@&quot;destinationPath&quot;]</span><br><span class="line">process:first[@&quot;process&quot;]</span><br><span class="line">completion:first[@&quot;completion&quot;]</span><br><span class="line">failure:first[@&quot;failure&quot;]];</span><br><span class="line">//从排队对列中移除一个下载任务</span><br><span class="line">[_queue removeObjectAtIndex:0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加下载任务：判断是否超过允许的最大的并发任务数，若大于，则进入队列派对，反之则搞一个下载类去下载这个任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-(void)downloadWithUrlString:(NSString *)urlString toPath:(NSString *)destinationPath process:(ProcessHandle)process completion:(CompletionHandle)completion failure:(FailureHandle)failure&#123;</span><br><span class="line"></span><br><span class="line">//若同时下载的任务数超过最大同时下载任务数，</span><br><span class="line">//则把下载任务存入对列，在下载完成后，自动进入下载。</span><br><span class="line">if(_taskDict.count&gt;=kFGGDwonloadMaxTaskCount)&#123;</span><br><span class="line"></span><br><span class="line">NSDictionary *dict=@&#123;@&quot;urlString&quot;:urlString,</span><br><span class="line">@&quot;destinationPath&quot;:destinationPath,</span><br><span class="line">@&quot;process&quot;:process,</span><br><span class="line">@&quot;completion&quot;:completion,</span><br><span class="line">@&quot;failure&quot;:failure&#125;;</span><br><span class="line">[_queue addObject:dict];</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">FGGDownloader *downloader=[FGGDownloader downloader];</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">[_taskDict setObject:downloader forKey:urlString];</span><br><span class="line">&#125;</span><br><span class="line">[downloader downloadWithUrlString:urlString</span><br><span class="line">toPath:destinationPath</span><br><span class="line">process:process</span><br><span class="line">completion:completion</span><br><span class="line">failure:failure];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>取消下载任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  取消下载任务</span><br><span class="line">*</span><br><span class="line">*  @param url 下载的链接</span><br><span class="line">*/</span><br><span class="line">-(void)cancelDownloadTask:(NSString *)url&#123;</span><br><span class="line"></span><br><span class="line">FGGDownloader *downloader=[_taskDict objectForKey:url];</span><br><span class="line">[downloader cancel];</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">[_taskDict removeObjectForKey:url];</span><br><span class="line">&#125;</span><br><span class="line">if(_queue.count&gt;0)&#123;</span><br><span class="line"></span><br><span class="line">NSDictionary *first=[_queue objectAtIndex:0];</span><br><span class="line"></span><br><span class="line">[self downloadWithUrlString:first[@&quot;urlString&quot;]</span><br><span class="line">toPath:first[@&quot;destinationPath&quot;]</span><br><span class="line">process:first[@&quot;process&quot;]</span><br><span class="line">completion:first[@&quot;completion&quot;]</span><br><span class="line">failure:first[@&quot;failure&quot;]];</span><br><span class="line">//从排队对列中移除一个下载任务</span><br><span class="line">[_queue removeObjectAtIndex:0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>取消所有下载任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(void)cancelAllTasks&#123;</span><br><span class="line"></span><br><span class="line">[_taskDict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</span><br><span class="line">FGGDownloader *downloader=obj;</span><br><span class="line">[downloader cancel];</span><br><span class="line">[_taskDict removeObjectForKey:key];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>彻底移除下载任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*  彻底移除下载任务</span><br><span class="line">*</span><br><span class="line">*  @param url  下载链接</span><br><span class="line">*  @param path 文件路径</span><br><span class="line">*/</span><br><span class="line">-(void)removeForUrl:(NSString *)url file:(NSString *)path&#123;</span><br><span class="line"></span><br><span class="line">FGGDownloader *downloader=[_taskDict objectForKey:url];</span><br><span class="line">if(downloader)&#123;</span><br><span class="line">[downloader cancel];</span><br><span class="line">&#125;</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">[_taskDict removeObjectForKey:url];</span><br><span class="line">&#125;</span><br><span class="line">NSUserDefaults *usd=[NSUserDefaults standardUserDefaults];</span><br><span class="line">NSString *totalLebgthKey=[NSString stringWithFormat:@&quot;%@totalLength&quot;,url];</span><br><span class="line">NSString *progressKey=[NSString stringWithFormat:@&quot;%@progress&quot;,url];</span><br><span class="line">[usd removeObjectForKey:totalLebgthKey];</span><br><span class="line">[usd removeObjectForKey:progressKey];</span><br><span class="line">[usd synchronize];</span><br><span class="line"></span><br><span class="line">NSFileManager *fileManager=[NSFileManager defaultManager];</span><br><span class="line">BOOL fileExist=[fileManager fileExistsAtPath:path];</span><br><span class="line">if(fileExist)&#123;</span><br><span class="line"></span><br><span class="line">[fileManager removeItemAtPath:path error:nil];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据url获取上次下载进度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(float)lastProgress:(NSString *)url&#123;</span><br><span class="line"></span><br><span class="line">return [FGGDownloader lastProgress:url];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据url获取上次下载大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(NSString *)filesSize:(NSString *)url&#123;</span><br><span class="line"></span><br><span class="line">return [FGGDownloader filesSize:url];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后在销毁的时候，移除通知：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(void)dealloc&#123;</span><br><span class="line"></span><br><span class="line">[[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后附上我的GitHub代码地址：<a href="https://github.com/Insfgg99x/FGGDownloader" target="_blank" rel="external">FGGDownloader</a>，欢迎pull request和star ~<br><img src="http://upload-images.jianshu.io/upload_images/937405-1e69ddd0ab142791.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[发布开源项目发布到cocoapods上去]]></title>
      <url>http://cgpointzero.top/2016/09/03/cocoapods-release-project/</url>
      <content type="html"><![CDATA[<p>发布开源项目到cocoapods上，可以让别人直接用cocoapods引用你的项目。<br>首先你需要安装cocoapods，如果你在安装出现了问题，请参考我的这篇帖子：<br><a href="http://www.jianshu.com/p/7846ef67153f" target="_blank" rel="external">解决安装cocoapods一直卡在Setting up master repos</a></p>
<p>######发布项目到cocoapods需要如下2个文件：<br><code>LICENSE</code>和<code>podspec</code>，即开源许可和规格说明文件，如下图:<br><img src="http://upload-images.jianshu.io/upload_images/937405-d8864eee92b83683.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>###LICENSE<br>一般采用<a href="https://opensource.org/licenses/MIT" target="_blank" rel="external">MIT</a>格式LICENSE如下:<br><br><br><img src="http://upload-images.jianshu.io/upload_images/937405-77ba31f6bdfadc02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>直接去这个网址<a href="https://opensource.org/licenses/MIT" target="_blank" rel="external">MIT</a>拷贝下来直接修改年份作者即可，也可以拿Github上别人的LICENSE，用文本编辑器打开来修改开源许可。</p>
<p>###podspec<br>项目的规格说明，如下面这个podspec：</p>
<p><pre>Pod::Spec.new do |s|<br>s.name                  = “FGGDownloader”<br>s.version               = “1.0”<br>s.ios.deployment_target = ‘6.0’<br>s.summary               = “FGGDownloader is used for resume from break point downloading.”<br>s.homepage              = “<a href="https://github.com/Insfgg99x/FGGDownloader" target="_blank" rel="external">https://github.com/Insfgg99x/FGGDownloader</a>“<br>s.license               = “MIT”<br>s.authors               = { “CGPointZero” =&gt; “newbox0512@yahoo.com” }<br>s.source                = { :git =&gt; “<a href="https://github.com/Insfgg99x/FGGDownloader.git" target="_blank" rel="external">https://github.com/Insfgg99x/FGGDownloader.git</a>“, :tag =&gt; “1.0” }<br>s.frameworks            = ‘Foundation’,’UIKit’<br>s.source_files          = ‘FGGDownloader/*.{h,m}’<br>s.requires_arc          = true<br>#s.dependency ‘SDWebImage’<br>#s.dependency ‘pop’<br>end</pre></p>
<p>######每一项都有自己的含义：</p>
<p><pre><br>s.name：名称，<b>pod search name</b> 的 name<br>s.version：版本号<br>s.ios.deployment_target:支持的pod最低版本<br>s.summary: 简介<br>s.homepage:项目的地址<br>s.license:开源许可<br>s.author:作者信息，表示格式为 { “[作者名]” =&gt; “[邮箱]” }<br>s.source:项目的git代码仓库的地址，如格式为:{:git =&gt; “[git代码仓库地址]”, tag =&gt; “[版本号]”}<br>s.frameworks:表示需要的框架,如’Foundation’，多个框架之间以英文逗号分隔。<br>s.source_files:别人通过你的pod引用文件的层级目录。<br>如我要引用FGGDownloader文件夹下的.h和.m文件，则可以写成’FGGDownloader/*.{h,m}’<br><img src="http://upload-images.jianshu.io/upload_images/937405-88b741350b73aab2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>s.requires_arc: 是否支持ARC<br>s.dependency：依赖的项目，如有多个，则写多行<br>#表示注释<br></pre></p>
<p>###如何生成podspec<br>两种方法：<br>1.拷贝别人项目的podspec文件，修改作者，简介，依赖等说明信息。<br>2.用中端cd到项目目录，输入<code>touch xxx.podspec</code>生成podspec文件，其中xxx代表你项目的名字，跟上面的<code>s.name</code>要一致。</p>
<p>###验证podspec文的有效性：<br>验证podspec的有效性，检查修复语法或者逻辑错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint xxx.podspec --verbose</span><br></pre></td></tr></table></figure></p>
<p>xxx代表你的项目名字，要与上面的<code>s.name</code>一致。<br>需要注意的是：这种验证方式，存在警告也会验证不通过。<br>我们用可以忽略警告的验证方式(<code>--allow-warnings</code>)，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint FGGDownloader.podspec --allow-warnings</span><br></pre></td></tr></table></figure></p>
<p>验证车成功后会提示<code>xxx.podspec passed validation.</code>，如：<br><img src="http://upload-images.jianshu.io/upload_images/937405-ff176f2aad7a6f60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>###为你的项目添加版本号<br>开源许可LICENSE和podspec都做好之后，将项目push到你的远程代码仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git  add .</span><br><span class="line">git commit -m&quot;添加开源许可和podspec&quot; </span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>
<p>发布开源项目到cocoapods上去需要添加版本号，用<code>git tag</code>添加版本号。<br><code>git tag -a 1.0.1 -m&quot;version 1.0.1&quot;</code><br>添加完版本号后，用’git tag’命令查看tag是否添加成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></p>
<p>将本地添加的tag同步到远程代码仓库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --tag</span><br></pre></td></tr></table></figure></p>
<p>如果你对<code>git tag</code>的操作存在问题，请参考我的这篇文章：<a href="http://www.jianshu.com/p/f5461fe1787a" target="_blank" rel="external">彩色的git lg</a></p>
<p>###万事具备<br>上面的准备工作都做好了，可以向cocoapods提交了。<br>我们可以通过<code>pod trunk命令提交我们的开源项目到cocoapods</code>。<br>但是，前提是，你得注册了trunk账号，用<code>pod trunk me</code>验证你是否注册了:</p>
<p>######若不是出现类似如下信息的，都是没注册的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/937405-368f30318753cc1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>###注册trunk账号<br>使用<code>pod trunk register</code>注册账号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk register xxx.@xxx.xx &quot;作者名&quot; --verbose</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>xxx.@xxx.xx</code>表示邮箱，如123@yahoo.com.<br>–verbose选项表示输出可见性.</p>
<p>注册好了之后，用<code>pod trunk me</code>验证注册信息.</p>
<p>###发布代码到cocoapods<br>该有的都准备好了，发布吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk push xxx.podspec --verbose</span><br></pre></td></tr></table></figure></p>
<p>上面的xxx表示项目名，要和<code>s.name</code>保持一致.<br>需要注意的是，这种提交命令，不允许你的podspec文件存在警告。若存在警告，则不能通过有效性验证，导致发布失败！</p>
<p>我们可以加上允许警告的选项(–allow-warnings)如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk push FGGDownloader.podspec --allow-warnings</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/937405-5bd9fe2135ab2aa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>验证是否发布成功：<br><code>pod search xxx</code><br>xxx表示你的项目名，要和上面的<code>s.name</code> 保持一致。若能查找到，表示发布成功。</p>
<p>你也可以在<a href="https://cocoapods.org" target="_blank" rel="external">cocoapods官网</a>搜索你的项目来验证，但一般官网存在延迟，发布后不能立即搜出来，可能要等到第二天甚至第三天。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/937405-4643d30e062a2acb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在cocoapods官网搜索验证"><br><img src="http://upload-images.jianshu.io/upload_images/937405-e91a649f7a7df2a0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[解决安装cocoapods一直卡在Setting up master repos]]></title>
      <url>http://cgpointzero.top/2016/09/03/cocoapod-setup/</url>
      <content type="html"><![CDATA[<p>#首先卸载之前安装的cocoapods:<br>打开终端，输入：<code>which pod</code>会得到一个地址，如<code>/usr/local/bin/pod</code><br>输入<code>sudo rm -rf /usr/local/bin/pod</code>删除pod，后面的路径就是上面的路径</p>
<p>接着输入<code>gem list</code>得到如下列表：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/937405-2237beb0846859a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>##删除cocoapods部分：<br><code>sudo gem uninstall cocoapods -v 1.0.1</code><br><code>sudo gem uninstall cocoapods-core -v 1.0.1</code>后面的v1.0.1标示版本</p>
<p>##验证是否删除成功：<br><code>pod</code><br>得到<code>-bash pod :command not found</code>表示删除成功</p>
<p>##移除原来的源<br><code>gem source -l</code><br><code>gem sources  -r https://rubygems.org/</code></p>
<p>##添加国内源<br><code>gem sources -a https://gems.ruby-china.org/</code><br><code>gem source -l</code></p>
<p>##安装cocoapods<br><code>sudo gem install cocoapods</code>输入开机密码<br>若安装过程出现如下问题<br><code>ERROR:  While executing gem ... (Errno::EPERM)
Operation not permitted - /usr/bin/pod</code><br>解决办法是：<br><code>sudo gem install -n /usr/local/bin cocoapods</code>后面的路径是上面pod的路径</p>
<p>##初始化cocoapods<br>上一步安装完成之后，执行<code>pod setup</code>过几分钟到10分之后就完成初始化了。</p>
<p>##验证安装完成<br><code>pod search FGGDownloader</code>得到如下结果表示安装成功：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/937405-5b2baa3024cad79a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/937405-e91a649f7a7df2a0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[彩色的git lg]]></title>
      <url>http://cgpointzero.top/2016/09/01/colorfull_git/</url>
      <content type="html"><![CDATA[<p>#将git log替换成git lg，并且彩色显示，方便查看及回滚到某个版本，效果如下：<br><img src="/img/gitlog.png" alt="彩色的git lg"></p>
<p>#只要在命令行输入以下命令回车：</p>
<p>git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit”</p>
<p>#然后再git lg就可以看到彩色的日志。</p>
<p>#附上常用git 命令<br><code>1.初始化 git init<br>2.查看状态：git status<br>3.添加文件：git  add .<br>4.提交 git commit -m”备注”<br>5.查看日志：git log<br>6.查看当前分支：git branch<br>7.拉取最新代码：git pull origin 分支名<br>8.推送代码：git push origin 分支名<br>9.删除远程分支：git push origin :分支名<br>10.新建分支，并切换到新建的分支:git checkout -b 新分支名<br>11.将新建的分支推送到服务器：git push origin 新建的分支名<br>12.删除本地分支：git branch -D 分支名<br>13.合并某个分支到当前分支：git merge 需要合并到当前分支的分支名<br>14.强制回撤到某次提交的版本：git reset —hard 版本号的前6位(如：abe75e)<br>15.添加tag：git tag -a “标签名” -m”备注”<br>16.将添加的标签推送到远程服务器：git push —tag<br>17.进入到某哥tag:git checkout 标签名<br>18.强制回撤到某个标签：git reset —hard 标签名<br>19.删除本地tag：git tag -d 标签名<br>20.删除远程的tag：git push origin -–delete tag 标签名<br></code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JSPatch热补丁实时修复bug]]></title>
      <url>http://cgpointzero.top/2016/08/19/JSPatchABC/</url>
      <content type="html"><![CDATA[<p>###背景<br>在iOS开发中，存在bug修复周期长的问题。若程序出了bug，往往需要走一下步骤：<br>修改代码–打包–提交审核(–审核被拒–修改代码–再次提交审核)–用户更新。<br>需要很长一个周期才能解决问题。而JSPatch的出现，有效的解决了这一尴尬的局面。</p>
<p>###热修复<br>一种即时修复bug的技术，也叫hotfix。</p>
<p>###什么是JSPatch？<br><a href="https://github.com/bang590/JSPatch" target="_blank" rel="external">JSPatch</a>是一个一个动态更新的开源的框架，可以实时的修复bug(热修复)、添加新功能。从服务器下发补丁js补丁代码，客户端接收到补丁后，进行安全校验，然后用JS调用或替换原来crash的OC方法，从而达到实时修复bug的目的，过程如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/937405-1f31b1129e5a164b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>###示例<br>假如，在<code>LeftViewControler</code>的<code>tableView:didSelectRowAtIndexPath:</code>方法中存在一个数组越界的crash：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123;</span><br><span class="line"></span><br><span class="line">//---------------crash----------------</span><br><span class="line">NSArray *array=@[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;];</span><br><span class="line">for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">NSLog(@&quot;%@&quot;,array[i]); //程序中出现的crash(数组越界)</span><br><span class="line">&#125;</span><br><span class="line">//---------------crash---------------</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以在服务端用js下发一段这样的代码，达到实时修复bug的目的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">defineClass(&apos;LeftViewController&apos;, &#123;</span><br><span class="line">tableView_didSelectRowAtIndexPath: function(tableView, indexPath) &#123;</span><br><span class="line"></span><br><span class="line">var array = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;];</span><br><span class="line">for (var i = 0; i &lt; array.count(); i++) &#123;</span><br><span class="line">NSLog(&quot;%&quot;, array[i]); </span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们可以在项目中引入JSPatch，然后在在自己搭建下发补丁的服务器，也可以直接用<a href="http://jspatch.com" target="_blank" rel="external">JSPatch平台</a>集成的带代码下发功能的SDK，我们只需要写好补丁，直接就可以在这个平台下发了。</p>
<p>###步骤如下：</p>
<ul>
<li>第一步：在<a href="http://jspatch.com" target="_blank" rel="external">JSPatch平台</a>注册一个帐号；</li>
<li>第二步：创建一个app；</li>
<li>第三步：下载JSPatch SDK，这个跟github上的不一样，github上的是开源的，不带代码下发服务器的。</li>
<li>第四步：生成RSA公钥和私钥。<br>打开终端，cd到Desktop/，输入<code>openssl</code>后按回车，输入以下三行指令，<br><code>genrsa -out rsa_private_key.pem 1024</code><br><code>pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM –nocrypt</code><br><code>rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem</code><br>在桌面时就会得到2个<code>.pem</code>文件，分别时公钥和私钥。私钥用于服务端甲米下发的补丁，公钥用于客服端解密补丁。</li>
<li><p>第五步：按照文档集成SDK到文档中。<br>在<code>application:didFinishLaunchingWithOptions:</code>方法中对<code>JSPatch</code>初始化<br>`<br>//初始化JSPatch<br>-(void)setupJSPatch{</p>
<p>  [JSPatch startWithAppKey:kJSPatchKey];<br>  [JSPatch setupRSAPublicKey:kRSAPublicKey];<br>  [JSPatch setupLogger:^(NSString *msg) {</p>
<pre><code>NSLog(@&quot;%@&quot;,msg);
</code></pre><p>  }];<br>  //[JSPatch testScriptInBundle];//沙盒测试<br>  [JSPatch sync];<br>}<code>其中，</code>appkey<code>是平台上创建app得到的appkey，而</code>pullic key<code>则是上步生成的</code>RSA公钥<code>，注意要手动加换行(\n)。如:</code>@”—–BEGIN PUBLIC KEY—–\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC1heHjbL+R6nulhIRptjfGmd3M\nlU…\n—–END PUBLIC KEY—–”。<br>`</p>
</li>
<li><p>下发补丁时，服务端会计算补丁文件(js)文件的<code>MD5</code>值，然后讲这个MD5值用<code>RSA私钥签名</code>，签名后的字符串跟补丁一起下发到客户端。</p>
</li>
<li><p>客户端拿到签名后的字符串后，用公钥进行<code>解密</code>，得到一个MD5值，计算得到脚本的MD5值，比较这两个MD5值，若一支，说明补丁<code>没被篡改</code>。若无篡改，则在运行时通过方法交换，替换掉我们的crash代码。</p>
</li>
<li><p>第六步：我们用在桌面上新建一个<code>main.js</code>文件，打开命令后，<code>cd</code>到桌面，输入<code>touch main.js</code>后回车，在桌面就会生成一个<code>main.js</code>文件，用文本编辑器打开。<br>写入我们自己的方法替换掉crash部分的代码的所在的方法。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">defineClass(&apos;LeftViewController&apos;, &#123;</span><br><span class="line"></span><br><span class="line">    tableView_didSelectRowAtIndexPath: function(tableView, indexPath) &#123;</span><br><span class="line"></span><br><span class="line">        var array = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;];</span><br><span class="line">        for (var i = 0; i &lt; array.count(); i++) &#123;</span><br><span class="line">            NSLog(&quot;%&quot;, array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你可以用<a href="https://github.com/bang590/JSPatchConvertor/blob/gh-pages/JSPatchConvertor.zip" target="_blank" rel="external">JSPatchConverter</a>直接将写好的<code>OC</code>转成<code>Patch</code>，大部分可以直接转，但<code>私有变量/静态变量/宏</code>这些还不支持，所以转换后需要<b>手动修改</b>。可以借助这个工具，省去原本要先写好<code>OC</code>代码，在翻译成<code>Patch</code>的时间成本。</p>
<ul>
<li><p>第七步：测试补丁的有效性<br>在下发补丁之前，我们可以验证补丁是否凑效，具体做法是：<br>将我们刚刚编辑的main.js导入项目根目录，选择copy。在JSPatch初始化的方法中，打开沙盒测试方法<code>[JSPatch testScriptInBundle];</code>，并注释掉其他JSPathch方法。运行程序，该测试方法会自动在沙盒下寻找<code>main.js</code>文件并执行，以验证bug是否被修复。</p>
</li>
<li><p>第八步：下发补丁<br>在上一步补丁有效性验证成功之后，去<a href="http://jspatch.com" target="_blank" rel="external">JSPatch平台</a>下发补丁。<br>补丁选择刚刚的<code>main.js</code>，私钥选择刚刚生成的私钥<code>private_key.pem</code>文件，提交。<br>注意：App版本号要跟<code>Bundle versions string, short</code>版本号一致！</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/937405-19df86d4b89682cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>第九步：运行app，再次在<code>LeftViewController</code>的选择cell，之前选择cell导致crash得到了修复!<br>至此，我们已经在不用重新提交版本的情况下，完成了bug的实时修复。</li>
</ul>
<p>至此，我们已经在不用重新提交版本的情况下，完成了bug的实时修复。<br><img src="http://upload-images.jianshu.io/upload_images/937405-e91a649f7a7df2a0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[两种方法实现UILabel图文并茂的显示html文本]]></title>
      <url>http://cgpointzero.top/2016/08/17/label-html/</url>
      <content type="html"><![CDATA[<p>本文讲述用2中方法在UILabel中显示带图片和文字的HTML文本。<br>先预览下显示效果：<br><img src="http://upload-images.jianshu.io/upload_images/937405-164214672d8ab9e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="显示效果"><br>如果你的设备时iOS 9或以上，默认只允许HTTPS，请打开HTTP请求许可，参照:<a href="http://www.jianshu.com/p/800637cce334" target="_blank" rel="external">iOS 9打开HTTP请求许可</a></p>
<p>第一种方案：</p>
<pre>
//HTML文本 包含图片、文本
NSString *htmlString=@"< img src=http://upload-images.jianshu.io/upload_images/937405-50a8ad2d8866fc12.png>&nbsp&nbsp花羊羊领取了你的<font color="\"red\""><a>红包</a></font>"
UILabel \*label=[UILabel alloc] initWithFrame:CGRectMake(50, 200, 220, 20)];
[self.view addSubview:label];
UIFont \*font=[UIFont systemFontOfSize:14];
label.font=font;
NSDictionary \\*optoins=@{NSDocumentTypeDocumentAttribute:NSHTMLTextDocumentType,
                            NSFontAttributeName:font};
NSData \*data=[htmlString dataUsingEncoding:NSUnicodeStringEncoding];
NSAttributedString \*attributeString=[[NSAttributedString alloc] initWithData:data
                                                                     options:optoins
                                                          documentAttributes:nil
                                                                       error:nil];
label.attributedText=attributeString;
</pre>
方案一点评：
这种方案只是实现了显示，显示效果好不好是另一回事。事实证明，这种方案的显示效果很不好：

![方案一显示效果](http://upload-images.jianshu.io/upload_images/937405-d810311964b43dab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

我们现在要对方案一进行优化。

方案一优化思路：1.缩小图片，让图片与字体显示差不多大；
2.让字体显示垂直方向居中。

优化后的方案一：

<pre>
//HTML文本 包含图片、文本
NSString *htmlString=@"< img src=http://upload-images.jianshu.io/upload_images/937405-50a8ad2d8866fc12.png>&nbsp&nbsp花羊羊领取了你的<font color="\"red\""><a>红包</a></font>"
//我们可以先把src对应的图片解析出来，放到本地
NSRange httpRange=[htmlString rangeOfString:@"http://"];
NSRange endRange=[htmlString rangeOfString:@".png"];
NSString \*picString=[htmlString substringWithRange:NSMakeRange(httpRange.location, endRange.location+endRange.length-httpRange.location)];
[[SDWebImageDownloader sharedDownloader] downloadImageWithURL:[NSURL URLWithString:picString] options:nil progress:nil completed:^(UIImage \\*image, NSData \\*data, NSError \*error, BOOL finished) {
    //按照字体大小缩小图片，具体实现在下文
     UIImage \\*scaledImage=[self scaleImage:image font:font];
     NSData \*imgData=UIImagePNGRepresentation(scaledImage);
     NSString \\*libPath=[NSSearchPathForDirectoriesInDomains(NSLibraryDirectory,     NSUserDomainMask, YES) lastObject];
    NSString \\*cachePath=[libPath stringByAppendingPathComponent:@"Caches"];
    NSString \\*scaledImagesPath=[cachePath stringByAppendingPathComponent:@"scaledImages"];
    if(![[NSFileManager defaultManager] fileExistsAtPath:scaledImagesPath]){
        [[NSFileManager defaultManager] createDirectoryAtPath:scaledImagesPath withIntermediateDirectories:YES attributes:nil error:nil];
    }
NSString\\ *picName=[[picString componentsSeparatedByString:@"/"] lastObject];
    NSString \\*filePath=[scaledImagesPath stringByAppendingPathComponent:picName];
    [imgData writeToFile:filePath atomically:YES];
    NSString \\*path=[NSURL fileURLWithPath:filePath].absoluteString;
//用本地的图片路径替换远程图片路径
htmlString=[htmlString stringByReplacingOccurrencesOfString:picString withString:path];
}];
UILabel \\*label=[UILabel alloc] initWithFrame:CGRectMake(50, 200, 220, 20)];
[self.view addSubview:label];
UIFont \\*font=[UIFont systemFontOfSize:14];
label.font=font;
NSDictionary \\*optoins=@{NSDocumentTypeDocumentAttribute:NSHTMLTextDocumentType,
                            NSFontAttributeName:font};
NSData \\*data=[htmlString dataUsingEncoding:NSUnicodeStringEncoding];
NSAttributedString \\*attributeString=[[NSAttributedString alloc] initWithData:data
                                                                     options:optoins
                                                          documentAttributes:nil
                                                                       error:nil];
label.attributedText=attributeString;
</pre>

<p><img src="http://upload-images.jianshu.io/upload_images/937405-aeaca04c3819680c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优化后的方案一显示效果"></p>
<p>优化后的方案一显示效果差强人意。这种方法成功的解决了图片大小的问题，以及文本不居中的问题，但图片没有居中对齐，网上也找不到方法，只有继续探寻。</p>
<p>方案二：</p>
<pre>
//HTML文本 包含图片、文本
NSString *htmlString=@"< img src=http://upload-images.jianshu.io/upload_images/937405-50a8ad2d8866fc12.png>&nbsp&nbsp花羊羊领取了你的<font color="\"red\""><a>红包</a></font>"
//我们可以先把src对应的图片解析出来，放到本地
NSRange httpRange=[htmlString rangeOfString:@"http://"];
NSRange endRange=[htmlString rangeOfString:@".png"];
NSString \*picString=[htmlString substringWithRange:NSMakeRange(httpRange.location, endRange.location+endRange.length-httpRange.location)];
UIImage \*scaledImage;
[[SDWebImageDownloader sharedDownloader] downloadImageWithURL:[NSURL URLWithString:picString] options:nil progress:nil completed:^(UIImage \*image, NSData \*data, NSError \*error, BOOL finished) {
    //按照字体大小缩小图片，具体实现在下文
     scaledImage=[self scaleImage:image font:font];
     NSData \*imgData=UIImagePNGRepresentation(scaledImage);
     NSString \*libPath=[NSSearchPathForDirectoriesInDomains(NSLibraryDirectory,     NSUserDomainMask, YES) lastObject];
    NSString \*cachePath=[libPath stringByAppendingPathComponent:@"Caches"];
    NSString \*scaledImagesPath=[cachePath stringByAppendingPathComponent:@"scaledImages"];
    if(![[NSFileManager defaultManager] fileExistsAtPath:scaledImagesPath]){
        [[NSFileManager defaultManager] createDirectoryAtPath:scaledImagesPath withIntermediateDirectories:YES attributes:nil error:nil];
    }
NSString \\*picName=[[picString componentsSeparatedByString:@"/"] lastObject];
    NSString \\*filePath=[scaledImagesPath stringByAppendingPathComponent:picName];
    [imgData writeToFile:filePath atomically:YES];
//用空字符串替换远程图片路径
htmlString=[htmlString stringByReplacingOccurrencesOfString:picString withString:@""];
}];


UILabel \*label=[UILabel alloc] initWithFrame:CGRectMake(50, 200, 220, 20)];
[self.view addSubview:label];
UIFont \*font=[UIFont systemFontOfSize:14];
label.font=font;
//利用NSTextAttachment文UILabel添加图片，并调整位置实现居中对齐
NSTextAttachment *attach=[[NSTextAttachment alloc] init];
attach.bounds=CGRectMake(2, -(label.frame.size.height-font.pointSize)/2, 12, 14);
attach.image=scaledImage;
NSMutableAttributedString \*componets=[[NSMutableAttributedString alloc] init];
NSAttributedString \*imagePart=[NSAttributedString attributedStringWithAttachment:attach];
[componets appendAttributedString:imagePart];
NSDictionary \*optoins=@{NSDocumentTypeDocumentAttribute:NSHTMLTextDocumentType,
                            NSFontAttributeName:font};
NSData \*data=[htmlString dataUsingEncoding:NSUnicodeStringEncoding];
NSAttributedString \*textPart=[[NSAttributedString alloc] initWithData:data
                                                                     options:optoins
                                                          documentAttributes:nil
                                                                       error:nil];
[componets appendAttributedString:textPart];
label.attributedText=componets;
</pre>

<p><img src="http://upload-images.jianshu.io/upload_images/937405-e31040e80be7cc90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方案二的显示效果"><br>点评：<br>方案二显示效果略复杂，但是达到了我们需要的正常显示效果。</p>
<p>最后，附上根据字体大小缩小图片的方法：</p>
<pre>
-(UIImage \*)scaleImage:(UIImage \*)origin font:(UIFont \*)font{

    CGFloat imgH=origin.size.height;
    CGFloat imgW=origin.size.width;
    CGFloat width;
    CGFloat height;
    CGFloat fontHeight=font.pointSize;
    if(imgW>imgH){

        width=fontHeight;
        height=fontHeight/imgW\*imgH;
    }
    else{
        height=fontHeight;
        width=fontHeight/imgH\*imgW;
    }
    UIGraphicsBeginImageContext(CGSizeMake(width, height));
    [origin drawInRect:CGRectMake(0, 0, width, height)];
    UIImage \*scaledImage=UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return scaledImage;
}
</pre>

<p><img src="http://upload-images.jianshu.io/upload_images/937405-e91a649f7a7df2a0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[class_copyIvarList的实用举例]]></title>
      <url>http://cgpointzero.top/2016/05/26/Ivar/</url>
      <content type="html"><![CDATA[<p>当一个模型有很多属性，给定的需求需要获取所有的属性的时候，如果一个一个写，效率很低，这个时候就可以用class_copyIvarList解决了。<br>例如有这样一个类：</p>
<p><pre></pre></p>
<p>#import <foundation foundation.h=""></foundation></p>
<p>@interface Model : NSObject</p>
<p>@property(nonatomic,copy)NSString *name;<br>@property(nonatomic,copy)NSString *sex;<br>@property(nonatomic,copy)NSString *idno;<br>@property(nonatomic,copy)NSString *address;<br>@property(nonatomic,copy)NSString *mobile;</p>
<p>+(instancetype)modelWithValues:(NSArray *)values;</p>
<p>@end<br><br>现在需要获取他的以key=value的形式打印其所有属性及其值。就可以这样写了：<br><code><br>-(NSString <em>)description{<br>    unsigned int count=0;<br>    Ivar </em>list=class_copyIvarList([self class], &amp;count);<br>    NSMutableArray <em>resultArray=[NSMutableArray array];<br>    for(int i=0;i&lt;count;i++){<br>        Ivar var=list[i];<br>        NSString </em>varName=[NSString stringWithUTF8String:ivar_getName(var)];<br>        //去掉前面的下划线<br>        NSString *tmp=[varName substringFromIndex:1];<br>        SEL method=NSSelectorFromString(tmp);</code></p>
<pre><code>    #pragma clang diagnostic push
    #pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;
    id value=[self performSelector:method];
    #pragma clang diagnostic pop
    if(!value||value==NULL){
        value=@&quot;&quot;;
    }
    NSString *item=[NSString stringWithFormat:@&quot;%@=%@&quot;,tmp,value];

    [resultArray addObject:item];
}
free(list);
return [resultArray componentsJoinedByString:@&quot;&amp;&quot;];
</code></pre><p>}<br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[runtime运行时方法替换的用法]]></title>
      <url>http://cgpointzero.top/2016/05/26/runtime/</url>
      <content type="html"><![CDATA[<p>在load方法中，用fc_viewDidLoad替换viewDidLoad：</p>
<pre>
/**
 *  在load中交换viewDidLoad和fc_viewDidLoad
 */
+(void)load{

    static dispatch_once_t onceToken;
    dispatch_once(&onceToken,^{

        xgf_swizzleSelector([self class], @selector(viewDidLoad), @selector(xgf_viewDidLoad));

        /*Method m1=class_getInstanceMethod([self class], @selector(viewDidLoad));
        Method m2=class_getInstanceMethod([self class], @selector(fc_viewDidLoad));
        BOOL notImplemented=class_addMethod([self class], @selector(viewDidLoad), method_getImplementation(m2), method_getTypeEncoding(m2));
        if(!notImplemented){
        method_exchangeImplementations(m1, m2);
        }
        */
    });
}
static inline void xgf_swizzleSelector(Class class,SEL originalSelector,SEL swizzledSelector){

    Method originalMethod=class_getInstanceMethod(class, originalSelector);
    Method swizzledMethod=class_getInstanceMethod(class, swizzledSelector);
    if(class_addMethod(class, 
                       originalSelector, 
                       method_getImplementation(swizzledMethod),
                       method_getTypeEncoding(swizzledMethod))){
        class_replaceMethod(class, swizzledSelector,
                            method_getImplementation(originalMethod), 
                            method_getTypeEncoding(originalMethod));
    }else{
        method_exchangeImplementations(originalMethod, swizzledMethod);
    }
}
</pre><pre>
/**
 *  [self xgf_viewDidLoad] 其实是调用了viewDidLoad的实现
 */
-(void)xgf_viewDidLoad{
    NSLog(@"%s",__func__);
    [self xgf_viewDidLoad];
}
</pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UITableView自定义多选删除样式]]></title>
      <url>http://cgpointzero.top/2015/11/26/multiple/</url>
      <content type="html"><![CDATA[<p>Model.h</p>
<pre>#import <foundation foundation.h="">
@interface Model : NSObject
@property(nonatomic,strong)NSString *desc;
+(instancetype)modelWithDesc:(NSString *)desc;
@end</foundation></pre>
Model.m
<pre>#import "Model.h"

@implementation Model

+(instancetype)modelWithDesc:(NSString *)desc
{
    Model *m=[Model new];
    m.desc=desc;
    return m;
}
@end</pre>
CustomCell.h
<pre>#import <uikit uikit.h="">

@interface CustomCell : UITableViewCell

@property(nonatomic,strong)UILabel *titleLb;
@property(nonatomic,strong)UIButton *selectBtn;

@end</uikit></pre>
CustomCell.m
<pre>#import "CustomCell.h"
#define kWidth ([UIScreen mainScreen].bounds.size.width)

@implementation CustomCell

- (void)awakeFromNib {
}

- (void)setSelected:(BOOL)selected animated:(BOOL)animated {
    [super setSelected:selected animated:animated];
}
-(id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier
{
    if(self=[super initWithStyle:style reuseIdentifier:reuseIdentifier])
    {
        self.backgroundColor=[UIColor blackColor];
        [self createUI];
        self.selectionStyle=UITableViewCellSelectionStyleNone;
    }
    return self;
}
-(void)createUI
{
    for(UIView *sub in self.contentView.subviews)
        [sub removeFromSuperview];

    //选择按钮
    self.selectBtn=[[UIButton alloc]initWithFrame:CGRectMake(-20, 10, 20, 20)];
    [self.selectBtn setImage:[UIImage imageNamed:@"un_select"] forState:UIControlStateNormal];
    [self .selectBtn setImage:[UIImage imageNamed:@"select"] forState:UIControlStateSelected];
    [self.contentView addSubview:self.selectBtn];
    //默认隐藏
    self.selectBtn.hidden=YES;

    // 标题Lb
    self.titleLb=[[UILabel alloc]initWithFrame:CGRectMake(20, 0,kWidth-40, 40)];
    self.titleLb.textColor=[UIColor whiteColor];
    [self.contentView addSubview:self.titleLb];
}
@end</pre>
EditViewController.h
<pre>#import <uikit uikit.h="">

@interface EditViewController : UIViewController

@end</uikit></pre>
EditViewController.m
<pre>#import "EditViewController.h"
#import "CustomCell.h"
#import "Model.h"

#define kWidth ([UIScreen mainScreen].bounds.size.width)
#define kHeight ([UIScreen mainScreen].bounds.size.height)
#define RGB(r,g,b) ([UIColor colorWithRed:(r)/255.0f green:(g)/255.0f blue:(b)/255.0f alpha:1.0f])

@interface EditViewController ()<uitableviewdatasource,uitableviewdelegate>
{
    UITableView *_tbView;
    NSMutableArray *_dataArray;
    NSMutableArray *_delArray;
}
//底部工具栏
@property(nonatomic,strong)UIView *toolView;

@end

@implementation EditViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    [self setUp];
    [self initDataArray];
    [self createTbView];
    [self createBottomTools];
}
//初始设置
-(void)setUp
{
    self.automaticallyAdjustsScrollViewInsets=NO;
    //导航视图
    UIView *naviView=[[UIView alloc]initWithFrame:CGRectMake(0, 0, kWidth, 64)];
    naviView.backgroundColor=RGB(157, 25, 36);
    [self.view addSubview:naviView];
    //导航栏标题
    UILabel *titleLb=[[UILabel alloc]initWithFrame:CGRectMake(0, 20, kWidth, 44)];
    titleLb.text=@"编辑分组";
    titleLb.textColor=[UIColor whiteColor];
    titleLb.textAlignment=NSTextAlignmentCenter;
    titleLb.font=[UIFont systemFontOfSize:20];
    [naviView addSubview:titleLb];
    //编辑按钮
    UIButton *rightBtn=[[UIButton alloc]initWithFrame:CGRectMake(kWidth-60, 27, 40, 30)];
    [rightBtn setTitle:@"编辑" forState:UIControlStateNormal];
    [rightBtn setTitle:@"完成" forState:UIControlStateSelected];
    [rightBtn addTarget:self action:@selector(editAction:) forControlEvents:UIControlEventTouchUpInside];
    [self.view addSubview:rightBtn];
}
//初始化数组
-(void)initDataArray
{
    //初始化数据源数组
    _dataArray=[NSMutableArray array];

    [_dataArray addObject:[Model modelWithDesc:@"我的自选"]];
    [_dataArray addObject:[Model modelWithDesc:@"我关注的牛股"]];
    [_dataArray addObject:[Model modelWithDesc:@"环保牛股"]];
    //初始化删除数组
    _delArray=[NSMutableArray array];
}
//点击编辑按钮执行的方法
-(void)editAction:(UIButton *)sender
{
    [_tbView setEditing:!_tbView.isEditing animated:YES];
    sender.selected=!sender.isSelected;

    if(sender.isSelected)
    {
        NSArray *allCells=[_tbView visibleCells];
        for(CustomCell *cell in allCells)
        {
            cell.selectBtn.hidden=NO;
            cell.selectBtn.selected=NO;
        }
        //显示底部toolView
        [self showToolView];
    }
    else
    {
        NSArray *allCells=[_tbView visibleCells];
        for(CustomCell *cell in allCells)
            cell.selectBtn.hidden=YES;

        //隐藏底部toolView
        [self hideToolView];

        //执行删除
        [_dataArray removeObjectsInArray:_delArray];
        //清空删除数组
        [_delArray removeAllObjects];
        //刷新表视图
        [_tbView reloadData];
    }
}
//表视图
-(void)createTbView
{
    _tbView=[[UITableView alloc]initWithFrame:CGRectMake(0, 64, kWidth, kHeight-64)];
    _tbView.delegate=self;
    _tbView.dataSource=self;
    _tbView.backgroundColor=[UIColor blackColor];
    _tbView.separatorColor=[UIColor whiteColor];
    _tbView.separatorStyle=UITableViewCellSeparatorStyleSingleLine;
    [self.view addSubview:_tbView];
    _tbView.scrollEnabled=NO;
    _tbView.allowsSelectionDuringEditing=YES;
    _tbView.tableFooterView=[UIView new];
}
//底部工具栏
-(void)createBottomTools
{
    _toolView=[[UIView alloc]initWithFrame:CGRectMake(0, kHeight, kWidth, 49)];
    _toolView.backgroundColor=[UIColor darkGrayColor];
    [self.view addSubview:_toolView];

    //全选按钮
    UIButton *selectAllBtn=[[UIButton alloc]initWithFrame:CGRectMake(10, 14.5, 20, 20)];
    [selectAllBtn setImage:[UIImage imageNamed:@"un_all_select"] forState:UIControlStateNormal];
    [selectAllBtn setImage:[UIImage imageNamed:@"select"] forState:UIControlStateSelected];
    [selectAllBtn addTarget:self action:@selector(selectAllRows:) forControlEvents:UIControlEventTouchUpInside];
    selectAllBtn.tag=100;
    [_toolView addSubview:selectAllBtn];

    //去选lb
    UILabel *selectAllLb=[[UILabel alloc]initWithFrame:CGRectMake(CGRectGetMaxX(selectAllBtn.frame)+5, 14.5, 40, 20)];
    selectAllLb.textColor=[UIColor whiteColor];
    selectAllLb.text=@"全选";
    selectAllLb.textAlignment=NSTextAlignmentCenter;
    [_toolView addSubview:selectAllLb];

    //删除数量
    UILabel *deleteCountLb=[[UILabel alloc]initWithFrame:CGRectMake(kWidth-70, 14.5, 60, 20)];
    deleteCountLb.text=@"删除(0)";
    deleteCountLb.textAlignment=NSTextAlignmentCenter;
    deleteCountLb.textColor=[UIColor whiteColor];
    deleteCountLb.tag=111;
    [_toolView addSubview:deleteCountLb];

    //默认隐藏
    _toolView.hidden=YES;
}
//全选
-(void)selectAllRows:(UIButton *)sender
{
    sender.selected=!sender.isSelected;
    if(_delArray.count<_dataarray.count) {="" for(model="" *m="" in="" _dataarray)="" if(![_delarray="" containsobject:m])="" [_delarray="" addobject:m];="" }="" nsarray="" *allcells="[_tbView" visiblecells];="" for(customcell="" *cell="" allcells)="" cell.selectbtn.selected="YES;" else="" removeallobjects];="" [self="" refreshdeletecountlb];="" 显示工具栏="" -(void)showtoolview="" __weak="" typeof(self)="" weakself="self;" uilabel="" *deletecountlb="(UILabel" *)[self.toolview="" viewwithtag:111];="" deletecountlb.text="@"删除(0)";" self.toolview.hidden="NO;" 全选标记置为否="" uibutton="" *selectallbtn="(UIButton" viewwithtag:100];="" selectallbtn.selected="NO;" [uiview="" animatewithduration:0.3="" animations:^{="" cgfloat="" ypos="weakSelf.toolView.frame.origin.y;" weakself.toolview.frame="CGRectMake(0," ypos,="" kwidth,="" 49);="" }];="" 隐藏工具栏="" -(void)hidetoolview="" }completion:^(bool="" finished)="" weakself.toolview.hidden="YES;" 刷新删除数量lb="" -(void)refreshdeletecountlb="" stringwithformat:@"删除(%ld)",_delarray.count];="" #pragma="" mark="" -="" uitableview="" -(nsinteger)tableview:(uitableview="" *)tableview="" numberofrowsinsection:(nsinteger)section="" return="" _dataarray.count;="" -(cgfloat)tableview:(uitableview="" heightforrowatindexpath:(nsindexpath="" *)indexpath="" 40;="" -(uitableviewcell="" *)tableview:(uitableview="" cellforrowatindexpath:(nsindexpath="" static="" nsstring="" *cid="@"cid";" customcell="" *cel="[tableView" dequeuereusablecellwithidentifier:cid];="" if(!cel)="" cel="[[CustomCell" alloc]initwithstyle:uitableviewcellstyledefault="" reuseidentifier:cid];="" model="" *model="_dataArray[indexPath.row];" cel.titlelb.text="model.desc;" cel;="" 编辑样式="" -(uitableviewcelleditingstyle)tableview:(uitableview="" editingstyleforrowatindexpath:(nsindexpath="" uitableviewcelleditingstylenone;="" 移动="" -(void)tableview:(uitableview="" moverowatindexpath:(nsindexpath="" *)sourceindexpath="" toindexpath:(nsindexpath="" *)destinationindexpath="" 交换数据="" [_dataarray="" exchangeobjectatindex:sourceindexpath.row="" withobjectatindex:destinationindexpath.row];="" 选中时执行的逻辑="" didselectrowatindexpath:(nsindexpath="" if(_tbview.isediting)="" 若选择了所有行，则将全选标记置为是="" if(_delarray.count="=_dataArray.count)" 全选标记置为是="" *)[_tbview="" cellforrowatindexpath:indexpath];="" removeobject:m];="" 置为未选中="" 刷新删除数lb="" @end="" <="" pre="">
Appdelegate.m
<pre>
＃import "AppDelegate.h"
＃import "EditViewController.h"
@interface AppDelegate ()
@end
@implementation AppDelegate
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    EditViewController *edit=[EditViewController new];
    UINavigationController *navi=[[UINavigationController alloc]initWithRootViewController:edit];
    navi.navigationBar.hidden=YES;
    navi.navigationBar.barStyle=UIBarStyleBlack;
    self.window.rootViewController=navi;
    return YES;
}</pre>

<p><img src="http://upload-images.jianshu.io/upload_images/937405-8a6d5aadc54c8000.gif?imageMogr2/auto-orient/strip" alt="效果图"><br>最后附上<a href="https://github.com/Insfgg99x/MultiDeleteAndMove" target="_blank" rel="external">GitHub源码地址</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/937405-231806b43dc36e61.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
</_dataarray.count)></uitableviewdatasource,uitableviewdelegate></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS静态库的制作]]></title>
      <url>http://cgpointzero.top/2015/11/03/static/</url>
      <content type="html"><![CDATA[<p><a href="http://www.jianshu.com/p/d70a51be5af1" target="_blank" rel="external">iOS静态库的制作</a></p>
]]></content>
    </entry>
    
  
  
</search>
